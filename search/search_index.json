{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Leetcode problems Getting Started \u00b6 On this website, you will find the solutions to Leetcode problems in Java , C++ and Python along with time & space complexities.","title":"Introduction"},{"location":"#getting-started","text":"On this website, you will find the solutions to Leetcode problems in Java , C++ and Python along with time & space complexities.","title":"Getting Started"},{"location":"tags/","text":"Tags \u00b6 Following is a list of tags: Array \u00b6 1. Two Sum 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 200. Number of Islands 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 216. Combination Sum III 268. Missing Number 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 51. N-Queens 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix Backtracking \u00b6 216. Combination Sum III 51. N-Queens 797. All Paths From Source to Target Binary Search \u00b6 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix Binary Search Tree \u00b6 700. Search in a Binary Search Tree Binary Tree \u00b6 700. Search in a Binary Search Tree Bit Manipulation \u00b6 268. Missing Number Breadth-First Search \u00b6 200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target Bucket Sort \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Combinatorics \u00b6 62. Unique Paths Counting \u00b6 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 347. Top K Frequent Elements 692. Top K Frequent Words Depth-First Search \u00b6 200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target Divide and Conquer \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Dynamic Programming \u00b6 62. Unique Paths Graph \u00b6 797. All Paths From Source to Target Hash Table \u00b6 1. Two Sum 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words 73. Set Matrix Zeroes Heap (Priority Queue) \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Linked List \u00b6 1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List Math \u00b6 268. Missing Number 537. Complex Number Multiplication 62. Unique Paths Matrix \u00b6 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix Quick Select \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Recursion \u00b6 203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code Simulation \u00b6 1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game Sorting \u00b6 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words Stack \u00b6 2130. Maximum Twin Sum of a Linked List 682. Baseball Game String \u00b6 1880. Check if Word Equals Summation of Two Words 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 344. Reverse String 537. Complex Number Multiplication Tree \u00b6 700. Search in a Binary Search Tree Two Pointers \u00b6 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays Two pointers \u00b6 2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List Union Find \u00b6 200. Number of Islands 695. Max Area of Island","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of tags:","title":"Tags"},{"location":"tags/#array","text":"1. Two Sum 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 200. Number of Islands 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 216. Combination Sum III 268. Missing Number 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 51. N-Queens 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix","title":"Array"},{"location":"tags/#backtracking","text":"216. Combination Sum III 51. N-Queens 797. All Paths From Source to Target","title":"Backtracking"},{"location":"tags/#binary-search","text":"1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix","title":"Binary Search"},{"location":"tags/#binary-search-tree","text":"700. Search in a Binary Search Tree","title":"Binary Search Tree"},{"location":"tags/#binary-tree","text":"700. Search in a Binary Search Tree","title":"Binary Tree"},{"location":"tags/#bit-manipulation","text":"268. Missing Number","title":"Bit Manipulation"},{"location":"tags/#breadth-first-search","text":"200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target","title":"Breadth-First Search"},{"location":"tags/#bucket-sort","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Bucket Sort"},{"location":"tags/#combinatorics","text":"62. Unique Paths","title":"Combinatorics"},{"location":"tags/#counting","text":"2053. Kth Distinct String in an Array 2085 count common words with one occurrence 347. Top K Frequent Elements 692. Top K Frequent Words","title":"Counting"},{"location":"tags/#depth-first-search","text":"200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target","title":"Depth-First Search"},{"location":"tags/#divide-and-conquer","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Divide and Conquer"},{"location":"tags/#dynamic-programming","text":"62. Unique Paths","title":"Dynamic Programming"},{"location":"tags/#graph","text":"797. All Paths From Source to Target","title":"Graph"},{"location":"tags/#hash-table","text":"1. Two Sum 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words 73. Set Matrix Zeroes","title":"Hash Table"},{"location":"tags/#heap-priority-queue","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Heap (Priority Queue)"},{"location":"tags/#linked-list","text":"1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List","title":"Linked List"},{"location":"tags/#math","text":"268. Missing Number 537. Complex Number Multiplication 62. Unique Paths","title":"Math"},{"location":"tags/#matrix","text":"1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix","title":"Matrix"},{"location":"tags/#quick-select","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Quick Select"},{"location":"tags/#recursion","text":"203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code","title":"Recursion"},{"location":"tags/#simulation","text":"1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game","title":"Simulation"},{"location":"tags/#sorting","text":"268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words","title":"Sorting"},{"location":"tags/#stack","text":"2130. Maximum Twin Sum of a Linked List 682. Baseball Game","title":"Stack"},{"location":"tags/#string","text":"1880. Check if Word Equals Summation of Two Words 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 344. Reverse String 537. Complex Number Multiplication","title":"String"},{"location":"tags/#tree","text":"700. Search in a Binary Search Tree","title":"Tree"},{"location":"tags/#two-pointers","text":"1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays","title":"Two Pointers"},{"location":"tags/#two-pointers_1","text":"2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List","title":"Two pointers"},{"location":"tags/#union-find","text":"200. Number of Islands 695. Max Area of Island","title":"Union Find"},{"location":"problems/1-two-sum/","tags":["Array","Hash Table"],"text":"Leetcode Problem Link : https://leetcode.com/problems/two-sum/ Approach 1 : Brute Force Java C++ class Solution { public int [] twoSum ( int [] nums , int target ) { int n = nums . length ; for ( int i = 0 ; i < n ; i ++ ){ for ( int j = i + 1 ; j < n ; j ++ ) if ( nums [ i ] + nums [ j ] == target ) return new int [] { i , j }; } return new int [] { - 1 , - 1 }; } } class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { int n = nums . size (); for ( int i = 0 ; i < n ; i ++ ){ for ( int j = i + 1 ; j < n ; j ++ ) if ( nums [ i ] + nums [ j ] == target ) return { i , j }; } return { -1 , -1 }; } }; Time Complexity : O(n 2 ) where n is the length of array Space Complexity : O(1) Approach 2 : HashTable Approach Java public class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > (); for ( int i = 0 ; i < nums . length ; i ++ ){ int n1 = nums [ i ] ; int n2 = target - n1 ; if ( map . containsKey ( n2 )){ int result [] = new int [] { map . get ( n2 ), i }; return result ; } map . put ( nums [ i ] , i ); } return new int [ 2 ] ; } } Time Complexity : O(n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"1. Two Sum"},{"location":"problems/1222-queens-that-can-attack-the-king/","tags":["Array","Matrix","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/queens-that-can-attack-the-king/ Approach : Matrix Exploration + Simulation Java C++ class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [][] board = new boolean [ 8 ][ 8 ] ; for ( int i = 0 ; i < queens . length ; i ++ ) board [ queens [ i ][ 0 ]][ queens [ i ][ 1 ]] = true ; int [] dir = { 1 , 0 , - 1 }; for ( int dx : dir ){ for ( int dy : dir ){ if ( dx == 0 && dy == 0 ) continue ; int x = king [ 0 ] ; int y = king [ 1 ] ; while ( x + dx >= 0 && x + dx < 8 && y + dy >= 0 && y + dy < 8 ){ x += dx ; y += dy ; if ( board [ x ][ y ] ){ result . add ( Arrays . asList ( x , y )); break ; } } } } return result ; } } Time Complexity : O(1) i.e. O(8*8) as it is a 8*8 chessboard Space Complexity : O(1) i.e. O(8*8) as it is a 8*8 chessboard","title":"1222. Queens That Can Attack the King"},{"location":"problems/1351-count-negative-numbers-in-a-sorted-matrix/","tags":["Array","Binary Search","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/ Approach 1 : Brute Force Approach Java C++ class Solution { public int countNegatives ( int [][] grid ) { int count = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ){ for ( int j = 0 ; j < grid [ i ] . length ; j ++ ){ if ( grid [ i ][ j ] < 0 ) count ++ ; } } return count ; } } class Solution { public : int countNegatives ( vector < vector < int >>& grid ) { int count = 0 ; for ( int i = 0 ; i < grid . size (); i ++ ){ for ( int j = 0 ; j < grid [ i ]. size (); j ++ ){ if ( grid [ i ][ j ] < 0 ) count ++ ; } } return count ; } }; Time Complexity : O(m*n) where (m,n) is the dimension of the grid Space Complexity : O(1) Approach 2 : Binary Search (on each row) Java C++ class Solution { public int countNegatives ( int [][] grid ) { int count = 0 ; // m = no. of rows, n = no. of columns int m = grid . length , n = grid [ 0 ] . length ; for ( int i = 0 ; i < grid . length ; i ++ ){ int low = 0 , high = n - 1 ; // Apply Binary Search on each row while ( low <= high ){ int mid = low + ( high - low ) / 2 ; // If the number at 'mid' is -ve, // that means all the numbers to its right will also be -ve // So count them and solve for left part if ( grid [ i ][ mid ] < 0 ){ count += high - mid + 1 ; high = mid - 1 ; } // Otherwise, check if -ve number is present on right part else { low = mid + 1 ; } } } return count ; } } class Solution { public : int countNegatives ( int [][] grid ) { int count = 0 ; int m = grid . length , n = grid [ 0 ]. length ; for ( int i = 0 ; i < grid . length ; i ++ ){ int low = 0 , high = n - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( grid [ i ][ mid ] < 0 ){ count += high - mid + 1 ; high = mid - 1 ; } else { low = mid + 1 ; } } } return count ; } }; Time Complexity : O(m*log 2 n) where m = number of rows & n = number of columns Space Complexity : O(1)","title":"1351. Count Negative Numbers in a Sorted Matrix"},{"location":"problems/153-find-minimum-in-rotated-sorted-array/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Approach 1 : Linear Search Java class Solution { public int findMin ( int [] nums ) { int n = nums . length ; if ( n == 1 ) return nums [ 0 ] ; // No rotations at all if ( nums [ 0 ] <= nums [ n - 1 ] ) return nums [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ){ int prev = ( i + n - 1 ) % n ; int next = ( i + 1 ) % n ; if ( nums [ i ] <= nums [ prev ] && nums [ i ] <= nums [ next ] ) return nums [ i ] ; } return nums [ 0 ] ; } } Time Complexity : O(n) where n are the length of the array Space Complexity : O(1) Approach 2 : Modified Binary Search(Iterative) Java class Solution { public int findMin ( int [] nums ) { int n = nums . length ; int low = 0 , high = n - 1 ; while ( low <= high ){ // when array is already sorted if ( nums [ low ] <= nums [ high ] ) return nums [ low ] ; int mid = low + ( high - low ) / 2 ; int next = ( mid + 1 ) % n ; int prev = ( mid + n - 1 ) % n ; // The minimum element has special characteristic in rotated array // that it is less than elements to its left and to its right if ( nums [ mid ] <= nums [ prev ] && nums [ mid ] <= nums [ next ] ) return nums [ mid ] ; // if the nums[low] <= nums[mid], // it means the subarray to left of mid is sorted // so minimum element lies in right subarray of mid else if ( nums [ low ] <= nums [ mid ] ) low = mid + 1 ; // if the nums[mid] <= nums[high], // it means the subarray to right of mid is sorted // so minimum element lies in left subarray of mid else if ( nums [ mid ] <= nums [ high ] ) high = mid - 1 ; } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(1) Approach 3: Modified Binary Search(Recursive) Java class Solution { public int findMin ( int [] nums ) { return search ( nums , 0 , nums . length - 1 ); } public int search ( int nums [] , int low , int high ){ int n = nums . length ; if ( low <= high ){ // when array is already sorted if ( nums [ low ] <= nums [ high ] ) return nums [ low ] ; int mid = low + ( high - low ) / 2 ; int next = ( mid + 1 ) % n ; int prev = ( mid + n - 1 ) % n ; // The minimum element has special characteristic in rotated array // that it is less than elements to its left and to its right if ( nums [ mid ] <= nums [ prev ] && nums [ mid ] <= nums [ next ] ) return nums [ mid ] ; // if the nums[low] <= nums[mid], // it means the subarray to left of mid is sorted // so minimum element lies in right subarray of mid else if ( nums [ low ] <= nums [ mid ] ) return search ( nums , mid + 1 , high ); // if the nums[mid] <= nums[high], // it means the subarray to right of mid is sorted // so minimum element lies in left subarray of mid else if ( nums [ mid ] <= nums [ high ] ) return search ( nums , low , mid - 1 ); } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(log n) where n are the length of the array","title":"153. Find Minimum in Rotated Sorted Array"},{"location":"problems/1539-kth-missing-positive-number/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-missing-positive-number/ Approach : Modified Binary Search Java C++ class Solution { public int findKthPositive ( int [] arr , int k ) { int low = 0 , high = arr . length ; while ( low < high ){ int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] - mid - 1 < k ) low = mid + 1 ; else high = mid ; } return high + k ; } } Time Complexity : O(log n) where n = number of elements in array Space Complexity : O(1)","title":"1539. Kth Missing Positive Number"},{"location":"problems/1721-swapping-nodes-in-a-linked-list/","tags":["Linked List","Two Pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ Approach 1 : Simple & Intuitive approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapNodes ( ListNode head , int k ) { int n = 0 , curr = 0 ; ListNode ptr = head ; ListNode begin = head , end = head ; while ( ptr != null ){ ptr = ptr . next ; n ++ ; } ptr = head ; while ( ptr != null ){ if ( n - curr == k ) end = ptr ; curr ++ ; if ( curr == k ) begin = ptr ; ptr = ptr . next ; } int temp = begin . val ; begin . val = end . val ; end . val = temp ; return head ; } } Time Complexity : O(n) where n = number of nodes in linked list Space Complexity : O(1) Approach 2 : Slow - Fast Pointers Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapNodes ( ListNode head , int k ) { ListNode dummy = new ListNode ( 0 , head ); ListNode fast = dummy , slow = dummy ; ListNode tempNode = null ; while ( k -- > 0 ) fast = fast . next ; tempNode = fast ; while ( fast != null ) { fast = fast . next ; slow = slow . next ; } int temp = slow . val ; slow . val = tempNode . val ; tempNode . val = temp ; return dummy . next ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * swapNodes ( ListNode * head , int k ) { ListNode * dummy = new ListNode ( 0 , head ); ListNode * fast = dummy , * slow = dummy ; ListNode * tempNode = NULL ; while ( k -- > 0 ) fast = fast -> next ; tempNode = fast ; while ( fast != NULL ) { fast = fast -> next ; slow = slow -> next ; } int temp = slow -> val ; slow -> val = tempNode -> val ; tempNode -> val = temp ; return dummy -> next ; } }; Time Complexity : O(n) where n = number of nodes in linked list Space Complexity : O(1)","title":"1721. Swapping Nodes in a Linked List"},{"location":"problems/1773-count-items-matching-a-rule/","text":"Leetcode Problem Link : https://leetcode.com/problems/count-items-matching-a-rule/ Java class Solution { public int countMatches ( List < List < String >> items , String ruleKey , String ruleValue ) { int key = ruleKey . equals ( \"type\" ) ? 0 : ( ruleKey . equals ( \"color\" ) ? 1 : 2 ); int size = items . size (); int count = 0 ; for ( int i = 0 ; i < size ; i ++ ){ if ( items . get ( i ). get ( key ). equals ( ruleValue )) count ++ ; } return count ; } } Time Complexity : O(n) where n is the number of items Space Complexity : O(1)","title":"1773. Count Items Matching a Rule"},{"location":"problems/1880-check-if-word-equals-summation-of-two-words/","tags":["String"],"text":"Leetcode Problem Link : https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/ Approach : Formula Simulation Java C++ class Solution { public boolean isSumEqual ( String firstWord , String secondWord , String targetWord ) { int val1 = findValue ( firstWord ); int val2 = findValue ( secondWord ); int val3 = findValue ( targetWord ); return (( val1 + val2 ) == val3 ); } public int findValue ( String word ){ int val = 0 ; for ( int i = 0 ; i < word . length (); i ++ ) val = 10 * val + ( word . charAt ( i ) - 'a' ); return val ; } } Time Complexity : O(1) as each word's length is maximum 8 characters Space Complexity : O(1)","title":"1880. Check if Word Equals Summation of Two Words"},{"location":"problems/2-add-two-numbers/","text":"C++ Java class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( l1 || l2 || carry ) { if ( l1 ) { carry += l1 -> val ; l1 = l1 -> next ; } if ( l2 ) { carry += l2 -> val ; l2 = l2 -> next ; } curr -> next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr -> next ; } return dummy . next ; } }; class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { if ( l1 == null ) return l2 ; if ( l2 == null ) return l1 ; ListNode head = l1 , prev = null ; int carry = 0 ; while ( l1 != null && l2 != null ){ int sum = l1 . val + l2 . val + carry ; carry = sum / 10 ; l1 . val = sum % 10 ; prev = l1 ; l1 = l1 . next ; l2 = l2 . next ; } while ( l1 != null ){ int sum = l1 . val + carry ; carry = sum / 10 ; l1 . val = sum % 10 ; prev = l1 ; l1 = l1 . next ; } while ( l2 != null ){ int sum = l2 . val + carry ; carry = sum / 10 ; ListNode newnode = new ListNode ( sum % 10 ); prev . next = newnode ; prev = newnode ; l2 = l2 . next ; } if ( carry > 0 ){ ListNode newnode = new ListNode ( carry ); newnode . next = null ; prev . next = newnode ; } return head ; } }","title":"2. Add Two Numbers"},{"location":"problems/200-number-of-islands/","tags":["Array","Depth-First Search","Breadth-First Search","Union Find","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/number-of-islands/ Approach : DFS Java C++ class Solution { boolean [][] visited ; public int numIslands ( char [][] grid ) { int m = grid . length , n = grid [ 0 ] . length ; visited = new boolean [ m ][ n ] ; int islands = 0 ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( grid [ i ][ j ] == '1' && ! visited [ i ][ j ] ) islands += explore ( grid , m , n , i , j ); } } return islands ; } public int explore ( char [][] grid , int m , int n , int row , int col ){ // base case 1: if we go out of bounds of the matrix if ( row < 0 || col < 0 || row >= m || col >= n ) return 0 ; // base case 2: if we are not currently at island (grid[i][j] == '0') // or we have already visited this island if ( grid [ row ][ col ] == '0' || visited [ row ][ col ] ) return 0 ; // visit the current island visited [ row ][ col ] = true ; // recursively visit islands to left, right, above below int left = explore ( grid , m , n , row , col - 1 ); int right = explore ( grid , m , n , row , col + 1 ); int above = explore ( grid , m , n , row - 1 , col ); int below = explore ( grid , m , n , row + 1 , col ); return 1 ; } } Time Complexity : O(m*n) where m = numeber of rows, n = number of columns Space Complexity : O(m*n) where m = numeber of rows, n = number of columns","title":"200. Number of Islands"},{"location":"problems/203-remove-linked-list-elements/","tags":["Linked List","Recursion"],"text":"Leetcode Problem Link : https://leetcode.com/problems/remove-linked-list-elements/ Approach 1 : Recursive Approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements ( ListNode head , int val ) { // Base case if ( head == null ) return head ; // Recursively remove nodes with value 'val' from the list ListNode node = removeElements ( head . next , val ); // if the head's val == val, then return the other part of the list if ( head . val == val ) return node ; // otherwise, head.next will point to list returned after solving recursively for rest part head . next = node ; return head ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { // Base case if ( ! head ) return head ; // Recursively remove nodes with value 'val' from the list ListNode * node = removeElements ( head -> next , val ); // if the head's val == val, then return the other part of the list if ( head -> val == val ) return node ; // otherwise, head.next will point to list returned after solving recursively for rest part head -> next = node ; return head ; } }; Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1) Approach 2 : Iterative Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements ( ListNode head , int val ) { if ( head == null ) return head ; ListNode prev = null , curr = head ; while ( curr != null ){ if ( curr . val == val ){ if ( prev == null ) head = curr . next ; else prev . next = curr . next ; } else prev = curr ; curr = curr . next ; } return head ; } } Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1)","title":"203. Remove Linked List Elements"},{"location":"problems/2053-kth-distinct-string-in-an-array/","tags":["Array","Hash Table","String","Counting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-distinct-string-in-an-array/ Approach : HashMap Java C++ class Solution { public String kthDistinct ( String [] arr , int k ) { Map < String , Integer > map = new LinkedHashMap < String , Integer > (); for ( String str : arr ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); int i = 0 ; for ( String word : arr ){ if ( map . getOrDefault ( word , 0 ) == 1 && ++ i == k ) return word ; } return \"\" ; } } Time Complexity : O(n) where n = size of array Space Complexity : O(n1 + n2) where n = size of array","title":"2053. Kth Distinct String in an Array"},{"location":"problems/206-reverse-linked-list/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/reverse-linked-list/ Approach 1 : Recursive approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) { return head ; } ListNode node = reverseList ( head . next ); head . next . next = head ; head . next = null ; return node ; } } Time Complexity : O(n) where n is number of nodes in linked list Space Complexity : O(1) Approach 2 : Iterative approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null , curr = head , next = null ; while ( curr != null ){ next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * next , * prev = NULL ; while ( head != NULL ) { next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Time Complexity : O(n) where n is number of nodes in linked list Space Complexity : O(1)","title":"206. Reverse Linked List"},{"location":"problems/2085-count-common-words-with-one-occurrence/","tags":["Array","Hash Table","String","Counting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/count-common-words-with-one-occurrence/ Approach : HashMap Java C++ class Solution { public int countWords ( String [] words1 , String [] words2 ) { Map < String , Integer > map1 = new HashMap < String , Integer > (); Map < String , Integer > map2 = new HashMap < String , Integer > (); for ( String word : words1 ) map1 . put ( word , map1 . getOrDefault ( word , 0 ) + 1 ); for ( String word : words2 ) map2 . put ( word , map2 . getOrDefault ( word , 0 ) + 1 ); int unique = 0 ; for ( String word : map1 . keySet ()){ int n1 = map1 . get ( word ); int n2 = map2 . getOrDefault ( word , 0 ); if ( n1 == 1 && n2 == 1 ) unique ++ ; } return unique ; } } Time Complexity : O(n1 + n2) where n1 = size of word1 array, n2 = size of word2 array Space Complexity : O(n1 + n2) where n1 = size of word1 array, n2 = size of word2 array","title":"2085 count common words with one occurrence"},{"location":"problems/2095-delete-the-middle-node-of-a-linked-list/","tags":["Linked List","Two pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Approach 1 : Naive Approach(Two pass solution) Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteMiddle ( ListNode head ) { if ( head == null || head . next == null ) return null ; int count = 0 ; ListNode ptr = head , prev = null ; while ( ptr != null ){ ptr = ptr . next ; count ++ ; } int mid = count / 2 ; ptr = head ; while ( mid -- > 0 ){ prev = ptr ; ptr = ptr . next ; } prev . next = ptr . next ; return head ; } } Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1) Approach 2 : Two Pointers Approach(One pass solution) Java Python /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteMiddle ( ListNode head ) { if ( head == null || head . next == null ) return null ; ListNode slow = head , fast = head , prev = null ; while ( fast != null && fast . next != null ){ fast = fast . next . next ; prev = slow ; slow = slow . next ; } prev . next = slow . next ; return head ; } } # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def deleteMiddle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if ( head == None or head . next == None ): return None slow , fast , prev = head , head , None while ( fast != None and fast . next != None ): fast = fast . next . next prev = slow slow = slow . next prev . next = slow . next return head Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1)","title":"2095. Delete the Middle Node of a Linked List"},{"location":"problems/21-merge-two-sorted-lists/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/merge-two-sorted-lists/ Approach 1: Recursive approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { // if list1 is empty return list2 if ( list1 == null ) return list2 ; // if list2 is empty return list1 if ( list2 == null ) return list1 ; if ( list1 . val < list2 . val ){ list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; } else { list2 . next = mergeTwoLists ( list1 , list2 . next ); return list2 ; } } } Time Complexity : O(m+n) where m and n are the length of the two lists respectively Space Complexity : O(1) Approach 2: Iterative approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode (); ListNode ptr = dummy ; while ( list1 != null && list2 != null ){ if ( list1 . val < list2 . val ){ ptr . next = list1 ; list1 = list1 . next ; } else { ptr . next = list2 ; list2 = list2 . next ; } ptr = ptr . next ; } if ( list1 == null ) ptr . next = list2 ; if ( list2 == null ) ptr . next = list1 ; return dummy . next ; } } Time Complexity : O(m+n) where m and n are the length of the two lists respectively Space Complexity : O(1)","title":"21. Merge Two Sorted Lists"},{"location":"problems/2130-maximum-twin-sum-of-a-linked-list/","tags":["Linked List","Two pointers","Stack"],"text":"Leetcode Problem Link : https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/ Approach 1 : Two pointers Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public int pairSum ( ListNode head ) { Stack < Integer > stack = new Stack < Integer > (); ListNode slow = head , fast = head ; while ( fast != null && fast . next != null ){ stack . push ( slow . val ); slow = slow . next ; fast = fast . next . next ; } int max = 0 ; while ( slow != null ){ int n1 = stack . pop (); int n2 = slow . val ; max = Math . max ( max ,( n1 + n2 )); slow = slow . next ; } return max ; } } Time Complexity : O(n) where n is the number of nodes in linked list Space Complexity : O(1)","title":"2130. Maximum Twin Sum of a Linked List"},{"location":"problems/216-combination-sum-iii/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/combination-sum-iii/ Approach : Backtracking Java C++ class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> combinationSum3 ( int k , int n ) { int min = k * ( k + 1 ) / 2 ; int max = 9 * ( 9 + 1 ) / 2 ; if ( min > n || max < n ) return result ; for ( int i = 1 ; i <= 9 ; i ++ ){ List < Integer > list = new ArrayList < Integer > (); list . add ( i ); find ( i , k - 1 , n - i , list ); } return result ; } public void find ( int curr , int k , int n , List < Integer > list ){ // base case: // if we used more than 'k' numbers OR their sum has exceeded 'n' if ( n < 0 || k < 0 ) return ; // if 'k' used numbers sum up exactly to 'n' if ( n == 0 && k == 0 ){ result . add ( new ArrayList < Integer > ( list )); return ; } // recursively solve for starting from next number // since we cannot use a number twice for ( int i = curr + 1 ; i <= 9 ; i ++ ){ list . add ( i ); find ( i , k - 1 , n - i , list ); list . remove ( new Integer ( i )); } return ; } } Time Complexity : ~O(1) since the constraints are small Space Complexity : ~O(1) since the constraints are small","title":"216. Combination Sum III"},{"location":"problems/268-missing-number/","tags":["Array","Hash Table","Math","Bit Manipulation","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/missing-number/ Approach 1: Sorting & linear search Java C++ class Solution { public int missingNumber ( int [] nums ) { Arrays . sort ( nums ); int n = nums . length ; for ( int i = 0 ; i < n ; i ++ ){ if ( nums [ i ] != i ) return i ; } return n ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int n = nums . size (); for ( int i = 0 ; i < n ; i ++ ){ if ( nums [ i ] != i ) return i ; } return n ; } }; Time Complexity : O(nlogn) where n is length of array Space Complexity : O(1) Approach 2: Using sum of first n natural numbers property Java C++ class Solution { public int missingNumber ( int [] nums ) { int n = nums . length ; int result = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ){ result -= nums [ i ] ; } return result ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int result = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ){ result -= nums [ i ]; } return result ; } }; Time Complexity : O(n) where n is length of array Space Complexity : O(1) Approach 3: Using XOR of the numbers Java C++ class Solution { public int missingNumber ( int [] nums ) { int result = nums . length ; for ( int i = 0 ; i < nums . length ; i ++ ){ result ^= i ; result ^= nums [ i ] ; } return result ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { int result = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ){ result ^= i ; result ^= nums [ i ]; } return result ; } }; Time Complexity : O(n) where n is length of array Space Complexity : O(1)","title":"268. Missing Number"},{"location":"problems/34-find-first-and-last-position-of-element-in-sorted-array/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Approach 1 : Linear Search Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = - 1 , lastOccurrence = - 1 ; for ( int i = 0 ; i < nums . length ; i ++ ){ if ( nums [ i ] == target ){ if ( firstOccurrence == - 1 ) firstOccurrence = lastOccurrence = i ; else lastOccurrence = i ; } } return new int [] { firstOccurrence , lastOccurrence }; } } Time Complexity : O(n) where n are the length of the array Space Complexity : O(1) Approach 2 : Modified Binary Search(Recursive) Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = firstBS ( nums , 0 , nums . length - 1 , target ); if ( firstOccurrence != - 1 ){ int lastOccurrence = lastBS ( nums , 0 , nums . length - 1 , target ); return new int [] { firstOccurrence , lastOccurrence }; } return new int [] { - 1 , - 1 }; } public int firstBS ( int nums [] , int low , int high , int target ){ if ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( mid == 0 && nums [ mid ] == target ) return 0 ; if ( nums [ mid ] == target && nums [ mid - 1 ] < target ) return mid ; if ( nums [ mid ] >= target ) return firstBS ( nums , low , mid - 1 , target ); else if ( nums [ mid ] < target ) return firstBS ( nums , mid + 1 , high , target ); } return - 1 ; } public int lastBS ( int nums [] , int low , int high , int target ){ if ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( mid == nums . length - 1 && nums [ mid ] == target ) return mid ; if ( nums [ mid ] == target && nums [ mid + 1 ] > target ) return mid ; if ( nums [ mid ] <= target ) return lastBS ( nums , mid + 1 , high , target ); else if ( nums [ mid ] > target ) return lastBS ( nums , low , mid - 1 , target ); } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(log n) where n are the length of the array Approach 3 : Modified Binary Search(Iterative) Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = firstBS ( nums , 0 , nums . length - 1 , target ); if ( firstOccurrence != - 1 ){ int lastOccurrence = lastBS ( nums , 0 , nums . length - 1 , target ); return new int [] { firstOccurrence , lastOccurrence }; } return new int [] { - 1 , - 1 }; } public int firstBS ( int nums [] , int low , int high , int target ){ int idx = - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ){ idx = mid ; high = mid - 1 ; } else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return idx ; } public int lastBS ( int nums [] , int low , int high , int target ){ int idx = - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ){ idx = mid ; low = mid + 1 ; } else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return idx ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(1)","title":"34. Find First and Last Position of Element in Sorted Array"},{"location":"problems/344-reverse-string/","tags":["Two Pointers","String","Recursion"],"text":"Leetcode Problem Link : https://leetcode.com/problems/reverse-string/ Approach 1: Recursive Approach Java C++ class Solution { public void reverseString ( char [] s ) { int i = 0 ; int j = s . length - 1 ; helper ( s , i , j ); } public void helper ( char [] s , int i , int j ){ if ( i > j ) return ; char temp = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = temp ; helper ( s , ++ i , -- j ); } } class Solution { public : void reverseString ( vector < char >& s ) { int i = 0 ; int j = s . size () - 1 ; while ( i < j ){ char temp = s [ i ]; s [ i ] = s [ j ]; s [ j ] = temp ; i ++ ; j -- ; } } }; Time Complexity : O(n) where n is the length of string Space Complexity : O(n) where n is the length of string Approach 2: Iterative Approach Java C++ class Solution { public void reverseString ( char [] s ) { int i = 0 , j = s . length - 1 ; while ( i < j ){ char temp = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = t ; i ++ ; j -- ; } } } class Solution { public : void reverseString ( vector < char >& s ) { int i = 0 , j = s . size () - 1 ; while ( i < j ){ char temp = s [ i ]; s [ i ] = s [ j ]; s [ j ] = temp ; i ++ ; j -- ; } } }; Time Complexity : O(n) where n is the length of string Space Complexity : O(1)","title":"344. Reverse String"},{"location":"problems/347-top-k-frequent-elements/","tags":["Array","Hash Table","Divide and Conquer","Sorting","Heap (Priority Queue)","Bucket Sort","Counting","Quick Select"],"text":"Leetcode Problem Link : https://leetcode.com/problems/top-k-frequent-elements/ Approach 1 : Using Heap (PriorityQueue) Java class Element { int freq , element ; public Element ( int element , int freq ) { this . element = element ; this . freq = freq ; } } class Solution { public int [] topKFrequent ( int [] nums , int k ) { // O(1) time if k == nums.length if ( k == nums . length ) return nums ; // create a map to store elements and their frequencies HashMap < Integer , Integer > map = new HashMap < Integer , Integer > (); // Minheap to store the top 'k' frequent elements PriorityQueue < Element > heap = new PriorityQueue < Element > (( e1 , e2 ) -> e1 . freq - e2 . freq ); for ( int i = 0 ; i < nums . length ; i ++ ) map . put ( nums [ i ] , map . getOrDefault ( nums [ i ] , 0 ) + 1 ); // add the unique elements of HashMap to Minheap for ( Integer i : map . keySet ()){ heap . add ( new Element ( i , map . get ( i ))); // if size of heap becomes > k, extract the min element if ( heap . size () > k ) heap . poll (); } // Now our min heap contains top 'k' frequent elements int top [] = new int [ k ] ; int i = 0 ; // Return the top 'k' frequent elements present in the heap while ( k -- > 0 ) top [ i ++] = heap . poll (). element ; return top ; } } Time Complexity : O(n*log k) where n is the length of array Space Complexity : O(n) where n is the length of array Approach 2 : HashMap + Sorting Java class Solution { public int [] topKFrequent ( int [] nums , int k ) { int [] result = new int [ k ] ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > (); // Hashmap which stores (element, frequency) for ( int i = 0 ; i < nums . length ; i ++ ) map . put ( nums [ i ] , map . getOrDefault ( nums [ i ] , 0 ) + 1 ); // Create a list from the map List < Map . Entry < Integer , Integer >> list = new LinkedList < Map . Entry < Integer , Integer >> ( map . entrySet ()); // Sort the list using lambda expression Collections . sort ( list , ( e1 , e2 ) -> e2 . getValue (). compareTo ( e1 . getValue ())); // put elements from sorted list to the result array int i = 0 ; for ( Map . Entry < Integer , Integer > itr : list ) { result [ i ++] = itr . getKey (); if ( i >= k ) break ; } return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"347. Top K Frequent Elements"},{"location":"problems/349-intersection-of-two-arrays/","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/intersection-of-two-arrays/ Approach : Sorting + Binary Search Java C++ class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { int n1 = nums1 . length , n2 = nums2 . length , i = 0 ; Set < Integer > set = new HashSet < Integer > (); int [] baseArr , searchArr ; Arrays . sort ( nums1 ); Arrays . sort ( nums2 ); if ( n1 < n2 ){ baseArr = nums1 ; searchArr = nums2 ; } else { baseArr = nums2 ; searchArr = nums1 ; } for ( int n : baseArr ){ if ( find ( searchArr , n )) set . add ( n ); } int result [] = new int [ set . size () ] ; Iterator < Integer > it = set . iterator (); while ( it . hasNext ()) result [ i ++] = it . next (); return result ; } public boolean find ( int nums [] , int target ){ int low = 0 , high = nums . length - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ) return true ; else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return false ; } } Time Complexity : O(nlogn + mlogm + nlogm) where n & m are size of arrays nums1 and nums2 Space Complexity : O(max(n, m)) where n & m are size of arrays nums1 and nums2","title":"349. Intersection of Two Arrays"},{"location":"problems/35-search-insert-position/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-insert-position/ Approach : Modified Binary Search Java C++ class Solution { public int searchInsert ( int [] nums , int target ) { int low = 0 , high = nums . length - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ) return mid ; if ( nums [ mid ] < target ) low = mid + 1 ; else high = mid - 1 ; } return low ; } } Time Complexity : O(log n) where n = number of elements in array Space Complexity : O(1)","title":"35. Search Insert Position"},{"location":"problems/51-n-queens/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/n-queens/ Approach : Recursion + Backtracking Java C++ class Solution { List < List < String >> result = new ArrayList < List < String >> (); public List < List < String >> solveNQueens ( int n ) { char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < board . length ; i ++ ) Arrays . fill ( board [ i ] , '.' ); place ( board , 0 ); return result ; } public void place ( char board [][] , int row ){ if ( row == board . length ){ List < String > list = new ArrayList < String > (); for ( int i = 0 ; i < board . length ; i ++ ) list . add ( String . valueOf ( board [ i ] )); result . add ( list ); return ; } for ( int col = 0 ; col < board . length ; col ++ ){ if ( isSafe ( board , row , col )){ board [ row ][ col ] = 'Q' ; place ( board , row + 1 ); board [ row ][ col ] = '.' ; } } } public boolean isSafe ( char [][] board , int row , int col ){ if ( ! columnSafe ( board , row , col ) || ! diagonalSafe ( board , row , col )) return false ; return true ; } public boolean columnSafe ( char [][] board , int row , int col ){ for ( int i = 0 ; i < board . length ; i ++ ){ if ( board [ i ][ col ] == 'Q' ) return false ; } return true ; } public boolean diagonalSafe ( char [][] board , int row , int col ){ // Primary diagonal for ( int i = row - 1 , j = col + 1 ; i >= 0 && j < board . length ; i -- , j ++ ) if ( board [ i ][ j ] == 'Q' ) return false ; // Secondary diagonal for ( int i = row - 1 , j = col - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) if ( board [ i ][ j ] == 'Q' ) return false ; return true ; } } Time Complexity : O(N!) where N is the number of queens Space Complexity : O(N) where N is the number of queens","title":"51. N-Queens"},{"location":"problems/537-complex-number-multiplication/","tags":["Math","String","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/complex-number-multiplication/ Approach : Formula Simulation Java C++ class Solution { public String complexNumberMultiply ( String num1 , String num2 ) { // e.g. nums1 = 1+1i, nums2 = 1+-1i // n1 = [\"1\", \"1i\"], n2 = [\"1\", \"-1i\"] String [] n1 = num1 . split ( \"\\\\+\" ); String [] n2 = num2 . split ( \"\\\\+\" ); // r1 = 1, r2 = 1 // c1 = 1, c2 = -1 // for c1, c2 ==> take 2nd part of splitted string from 0th index to second last index // this will exclude 'i' from the splitted string to get actual complex part int r1 = Integer . parseInt ( n1 [ 0 ] ); int r2 = Integer . parseInt ( n2 [ 0 ] ); int c1 = Integer . parseInt ( n1 [ 1 ] . substring ( 0 , n1 [ 1 ] . length () - 1 )); int c2 = Integer . parseInt ( n2 [ 1 ] . substring ( 0 , n2 [ 1 ] . length () - 1 )); int real = r1 * r2 + ( c1 * c2 *- 1 ); int complex = r1 * c2 + r2 * c1 ; String result = Integer . toString ( real ) + \"+\" + Integer . toString ( complex ) + \"i\" ; return result ; } } Time Complexity : O(1) Space Complexity : O(1)","title":"537. Complex Number Multiplication"},{"location":"problems/62-unique-paths/","tags":["Math","Dynamic Programming","Combinatorics"],"text":"Leetcode Problem Link : https://leetcode.com/problems/unique-paths/ Solution Video Approach 1 : Brute Force Try all possible cases to reach to the final position. Java class Solution { public int uniquePaths ( int m , int n ) { // base case if ( m == 1 || n == 1 ) return 1 ; // move down int downMove = uniquePaths ( m - 1 , n ); // move right int rightMove = uniquePaths ( m , n - 1 ); return downMove + rightMove ; } } Time Complexity : O(2 mn ) Space Complexity : O(max(m,n)) Approach 2 : Memoization Here, we store the value for number of unique paths calculated for cell(i, j), so that if we encounter same subproblem in further recursive calls, we can directly use the calculated value instead of re-calculating for that cell. Java class Solution { private Map < String , Integer > map = new HashMap < String , Integer > (); public int uniquePaths ( int m , int n ) { // base case if ( m == 1 || n == 1 ) return 1 ; // check if we have already calculated unique paths for cell(m, n) String cell = new String ( m + \",\" + n ); // if yes, then get its value from our memoization table if ( map . containsKey ( cell )) return map . get ( cell ); // else, explore the down move int downMove = uniquePaths ( m - 1 , n ); // explore the right move int rightMove = uniquePaths ( m , n - 1 ); // put the value obtained for unique paths from cell(m, n) map . put ( cell , downMove + rightMove ); return downMove + rightMove ; } } Time Complexity : O(2 mn ) Space Complexity : O(max(m,n)) Approach 3 : Dynamic Programming Using DP, we find the number of unique paths from a given cell is equal to as the sum of the values of its previous possible states. dp[i,j] = dp[i-1,j] + dp[i,j-1] gives us the idea. To reach the position (i, j) , the path should either be coming from (i-1, j) or (i, j-1) . Now, we can use either top-down or bottom-up approach to calculate the number of unique paths. Approach 3.1 : Top-Down Dynamic Programming We start from top-left corner i.e. (0, 0) and finding paths in forward approach by using the formula dp[i][j] = dp[i-1][j] + dp[i][j-1] . The base case here is when i == 0 || j == 0 , dp[i][j] = 1 . Here, dp[i][j] represents the number of paths from cell (0, 0) to cell (i, j). Java class Solution { public int uniquePaths ( int m , int n ) { int [][] dp = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( i == 0 || j == 0 ) dp [ i ][ j ] = 1 ; else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ] ; } } return dp [ m - 1 ][ n - 1 ] ; } } Time Complexity : O(m*n) Space Complexity : O(m*n) Approach 3.2: Bottom-Up Dynamic Programming We will start from the bottom-right corner (m, n) and find finding paths using backward approach using the formula dp[i][j] = dp[i+1][j] + dp[i][j+1] , where m = no. of rows and n = no. of columns. The base case here is when i == m-1 || j == n-1 , dp[i][j] = 1 . Here, dp[i][j] represents the number of paths from cell (m, n) to cell (i, j). Java class Solution { public int uniquePaths ( int m , int n ) { int [][] dp = new int [ m ][ n ] ; for ( int i = m - 1 ; i >= 0 ; i -- ){ for ( int j = n - 1 ; j >= 0 ; j -- ){ if ( i == m - 1 || j == n - 1 ) dp [ i ][ j ] = 1 ; else dp [ i ][ j ] = dp [ i ][ j + 1 ] + dp [ i + 1 ][ j ] ; } } return dp [ 0 ][ 0 ] ; } } Time Complexity : O(m*n) Space Complexity : O(m*n)","title":"62. Unique Paths"},{"location":"problems/682-baseball-game/","tags":["Array","Stack","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/baseball-game/ Approach : Simulation Java C++ class Solution { public int calPoints ( String [] ops ) { List < Integer > list = new ArrayList < Integer > (); int size = 0 , sum = 0 ; for ( String op : ops ){ if ( op . equals ( \"C\" )) list . remove ( -- size ); else if ( op . equals ( \"D\" )){ list . add ( list . get ( size - 1 ) * 2 ); size ++ ; } else if ( op . equals ( \"+\" )){ list . add ( list . get ( size - 1 ) + list . get ( size - 2 )); size ++ ; } else { list . add ( new Integer ( op )); size ++ ; } } for ( Integer i : list ) sum += i ; return sum ; } } Time Complexity : O(n) where n = number of operations Space Complexity : O(n) where n = number of operations","title":"682. Baseball Game"},{"location":"problems/692-top-k-frequent-words/","tags":["Array","Hash Table","Divide and Conquer","Sorting","Heap (Priority Queue)","Bucket Sort","Counting","Quick Select"],"text":"Leetcode Problem Link : https://leetcode.com/problems/top-k-frequent-elements/ Approach 1 : Using Heap (PriorityQueue) Java class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > result = new ArrayList < String > (); HashMap < String , Integer > map = new HashMap < String , Integer > (); // MaxHeap to store the strings based on their frequency Queue < String > heap = new PriorityQueue < String > ( ( e1 , e2 ) -> map . get ( e1 ) == map . get ( e2 ) ? e1 . compareTo ( e2 ) : map . get ( e2 ) - map . get ( e1 )); // Hashmap which stores (element, frequency) for ( String str : words ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); // Add the unique elements of HashMap to Maxheap for ( String str : map . keySet ()) heap . add ( str ); // Add the top 'k' frequent strings from heap into the result while ( k -- > 0 ) result . add ( heap . poll ()); return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array Approach 2 : HashMap + Sorting Java class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > result = new ArrayList < String > (); HashMap < String , Integer > map = new HashMap < String , Integer > (); // Hashmap which stores (element, frequency) for ( String str : words ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); // Create a list from the map List < Map . Entry < String , Integer >> list = new LinkedList < Map . Entry < String , Integer >> ( map . entrySet ()); // Sort the list using lambda expression Collections . sort ( list , ( e1 , e2 ) -> e1 . getValue () == e2 . getValue () ? e1 . getKey (). compareTo ( e2 . getKey ()) : e2 . getValue () - e1 . getValue ()); // put elements from sorted list to the result array int i = 0 ; for ( Map . Entry < String , Integer > itr : list ) { result . add ( itr . getKey ()); if ( ++ i >= k ) break ; } return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"692. Top K Frequent Words"},{"location":"problems/695-max-area-of-island/","tags":["Array","Depth-First Search","Breadth-First Search","Union Find","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/max-area-of-island/ Approach : DFS Java C++ class Solution { boolean [][] visited ; public int maxAreaOfIsland ( int [][] grid ) { int m = grid . length , n = grid [ 0 ] . length ; visited = new boolean [ m ][ n ] ; int largestArea = 0 ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( grid [ i ][ j ] == 1 && ! visited [ i ][ j ] ) largestArea = Math . max ( largestArea , explore ( grid , m , n , i , j )); } } return largestArea ; } public int explore ( int [][] grid , int m , int n , int row , int col ){ // base case 1: if we go out of bounds of the matrix if ( row < 0 || col < 0 || row >= m || col >= n ) return 0 ; // base case 2: if we are not currently at island (grid[i][j] == 0) // or we have already visited this island if ( grid [ row ][ col ] == 0 || visited [ row ][ col ] ) return 0 ; // visit the current island visited [ row ][ col ] = true ; // recursively visit islands to left, right, above below int left = explore ( grid , m , n , row , col - 1 ); int right = explore ( grid , m , n , row , col + 1 ); int above = explore ( grid , m , n , row - 1 , col ); int below = explore ( grid , m , n , row + 1 , col ); // maximum area would be 1 + sum of area of its neighbouring islands // we add 1 because we should also add current island's area int maxArea = 1 + left + right + above + below ; return maxArea ; } } Time Complexity : O(m*n) where m = numeber of rows, n = number of columns Space Complexity : O(m*n) where m = numeber of rows, n = number of columns","title":"695. Max Area of Island"},{"location":"problems/700-search-in-a-binary-search-tree/","tags":["Tree","Binary Search Tree","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Approach : Recursion Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode searchBST ( TreeNode root , int val ) { // if root is null, then return null if ( root == null ) return null ; // if root's val matches val, then return root if ( root . val == val ) return root ; // if root's val is greater than val, // so the target node will be in left subtree of root if ( root . val > val ) return searchBST ( root . left , val ); // otherwise, it means root's val is less than val, // so the target node will be in left subtree of root else return searchBST ( root . right , val ); } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * searchBST ( TreeNode * root , int val ) { // if root is null, then return null if ( ! root ) return root ; // if root's val matches val, then return root if ( root -> val == val ) return root ; // if root's val is greater than val, // so the target node will be in left subtree of root if ( root -> val > val ) return searchBST ( root -> left , val ); // otherwise, it means root's val is less than val, // so the target node will be in left subtree of root else return searchBST ( root -> right , val ); } }; Time Complexity : O(n) where n is the number of nodes in the tree Space Complexity : O(n)","title":"700. Search in a Binary Search Tree"},{"location":"problems/73-set-matrix-zeroes/","tags":["Array","Hash Table","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/set-matrix-zeroes/ Java class Solution { public void setZeroes ( int [][] matrix ) { Set < Integer > rows = new HashSet < Integer > (); Set < Integer > cols = new HashSet < Integer > (); for ( int i = 0 ; i < matrix . length ; i ++ ){ for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ){ if ( matrix [ i ][ j ] == 0 ){ rows . add ( i ); cols . add ( j ); } } } for ( int i = 0 ; i < matrix . length ; i ++ ){ for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ){ if ( rows . contains ( i ) || cols . contains ( j )){ matrix [ i ][ j ] = 0 ; } } } } } Time Complexity : O(m*n) where ( m,n ) is the dimension of matrix Space Complexity : O(m*n) where ( m,n ) is the dimension of matrix","title":"73. Set Matrix Zeroes"},{"location":"problems/74-search-a-2d-matrix/","tags":["Array","Binary Search","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-a-2d-matrix/ Approach : Binary Search Java C++ class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { int m = matrix . length , n = matrix [ 0 ] . length ; int top = 0 , bottom = m - 1 ; int left = 0 , right = n - 1 ; int row = 0 ; while ( top <= bottom ){ int mid = top + ( bottom - top ) / 2 ; if ( matrix [ mid ][ left ] <= target && matrix [ mid ][ right ] >= target ){ row = mid ; break ; } if ( matrix [ mid ][ left ] > target ) bottom = mid - 1 ; else if ( matrix [ mid ][ right ] < target ) top = mid + 1 ; } while ( left <= right ){ int mid = left + ( right - left ) / 2 ; if ( matrix [ row ][ mid ] == target ) return true ; if ( matrix [ row ][ mid ] < target ) left = mid + 1 ; else right = mid - 1 ; } return false ; } } Time Complexity : O(log m*n) where m = numeber of rows, n = number of columns Space Complexity : O(1)","title":"74. Search a 2D Matrix"},{"location":"problems/797-all-paths-from-source-to-target/","tags":["Backtracking","Depth-First Search","Breadth-First Search","Graph"],"text":"Leetcode Problem Link : https://leetcode.com/problems/all-paths-from-source-to-target/ Approach : DFS + Backtracking Java C++ class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> allPathsSourceTarget ( int [][] graph ) { findPaths ( 0 , graph , new ArrayList < Integer > ()); return result ; } public void findPaths ( int node , int [][] graph , List < Integer > list ){ // if node vertex is the target vertex, then add the list to result // since we have found one of the directed path to target // the list maintains the nodes we which are used to reach vertex 'node' if ( node == graph . length - 1 ){ list . add ( node ); result . add ( new ArrayList < Integer > ( list )); list . remove ( new Integer ( node )); return ; } // add the current node to the list list . add ( node ); // recursively find path for through adjacent vertices of current node for ( int i = 0 ; i < graph [ node ] . length ; i ++ ) findPaths ( graph [ node ][ i ] , graph , list ); // remove the node from the path list . remove ( new Integer ( node )); return ; } } Time Complexity : O(E) where E is the number of edges in DAG Space Complexity : O(V) where V is the number of vertices in DAG","title":"797. All Paths From Source to Target"},{"location":"problems/89-gray-code/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/gray-code/ Approach 1 : Simple Recursive Approach Java class Solution { public List < Integer > grayCode ( int n ) { List < Integer > result = new ArrayList < Integer > (); List < String > codes = generate ( n ); int size = codes . size (); // Convert the gray codes from binary strings to decimal values for ( int i = 0 ; i < size ; i ++ ) result . add ( Integer . parseInt ( codes . get ( i ), 2 )); return result ; } public List < String > generate ( int n ){ // Base Case if ( n == 1 ) return Arrays . asList ( new String [] { \"0\" , \"1\" }); // Recursively get (n-1)bit gray codes List < String > codes = generate ( n - 1 ); List < String > answer = new ArrayList < String > (); int size = codes . size (); // Append \"0\" to (n-1)bit gray codes from first to last for ( int i = 0 ; i < size ; i ++ ) answer . add ( new String ( \"0\" + codes . get ( i ))); // Append \"1\" to (n-1)bit gray codes from last to first for ( int i = size - 1 ; i >= 0 ; i -- ) answer . add ( new String ( \"1\" + codes . get ( i ))); // return the n-bit gray codes (binary strings) return answer ; } } Time Complexity : O() Space Complexity : O(2 n ) where n is number of gray code bits","title":"89. Gray Code"},{"location":"problems/896-middle-of-the-linked-list/","tags":["Linked List","Two pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/middle-of-the-linked-list/ Approach 1 : Two pointers Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head , fast = head ; while ( fast != null && fast . next != null ){ fast = fast . next . next ; slow = slow . next ; } return slow ; } } Time Complexity : O(n) where n is the number of nodes in linked list Space Complexity : O(1)","title":"876. Middle of the Linked List"},{"location":"tags/","text":"Tags \u00b6 Following is a list of tags: Array \u00b6 1. Two Sum 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 200. Number of Islands 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 216. Combination Sum III 268. Missing Number 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 51. N-Queens 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix Backtracking \u00b6 216. Combination Sum III 51. N-Queens 797. All Paths From Source to Target Binary Search \u00b6 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix Binary Search Tree \u00b6 700. Search in a Binary Search Tree Binary Tree \u00b6 700. Search in a Binary Search Tree Bit Manipulation \u00b6 268. Missing Number Breadth-First Search \u00b6 200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target Bucket Sort \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Combinatorics \u00b6 62. Unique Paths Counting \u00b6 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 347. Top K Frequent Elements 692. Top K Frequent Words Depth-First Search \u00b6 200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target Divide and Conquer \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Dynamic Programming \u00b6 62. Unique Paths Graph \u00b6 797. All Paths From Source to Target Hash Table \u00b6 1. Two Sum 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words 73. Set Matrix Zeroes Heap (Priority Queue) \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Linked List \u00b6 1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List Math \u00b6 268. Missing Number 537. Complex Number Multiplication 62. Unique Paths Matrix \u00b6 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix Quick Select \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Recursion \u00b6 203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code Simulation \u00b6 1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game Sorting \u00b6 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words Stack \u00b6 2130. Maximum Twin Sum of a Linked List 682. Baseball Game String \u00b6 1880. Check if Word Equals Summation of Two Words 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 344. Reverse String 537. Complex Number Multiplication Tree \u00b6 700. Search in a Binary Search Tree Two Pointers \u00b6 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays Two pointers \u00b6 2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List Union Find \u00b6 200. Number of Islands 695. Max Area of Island","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of tags:","title":"Tags"},{"location":"tags/#array","text":"1. Two Sum 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 200. Number of Islands 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 216. Combination Sum III 268. Missing Number 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 51. N-Queens 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix","title":"Array"},{"location":"tags/#backtracking","text":"216. Combination Sum III 51. N-Queens 797. All Paths From Source to Target","title":"Backtracking"},{"location":"tags/#binary-search","text":"1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix","title":"Binary Search"},{"location":"tags/#binary-search-tree","text":"700. Search in a Binary Search Tree","title":"Binary Search Tree"},{"location":"tags/#binary-tree","text":"700. Search in a Binary Search Tree","title":"Binary Tree"},{"location":"tags/#bit-manipulation","text":"268. Missing Number","title":"Bit Manipulation"},{"location":"tags/#breadth-first-search","text":"200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target","title":"Breadth-First Search"},{"location":"tags/#bucket-sort","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Bucket Sort"},{"location":"tags/#combinatorics","text":"62. Unique Paths","title":"Combinatorics"},{"location":"tags/#counting","text":"2053. Kth Distinct String in an Array 2085 count common words with one occurrence 347. Top K Frequent Elements 692. Top K Frequent Words","title":"Counting"},{"location":"tags/#depth-first-search","text":"200. Number of Islands 695. Max Area of Island 797. All Paths From Source to Target","title":"Depth-First Search"},{"location":"tags/#divide-and-conquer","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Divide and Conquer"},{"location":"tags/#dynamic-programming","text":"62. Unique Paths","title":"Dynamic Programming"},{"location":"tags/#graph","text":"797. All Paths From Source to Target","title":"Graph"},{"location":"tags/#hash-table","text":"1. Two Sum 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words 73. Set Matrix Zeroes","title":"Hash Table"},{"location":"tags/#heap-priority-queue","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Heap (Priority Queue)"},{"location":"tags/#linked-list","text":"1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List","title":"Linked List"},{"location":"tags/#math","text":"268. Missing Number 537. Complex Number Multiplication 62. Unique Paths","title":"Math"},{"location":"tags/#matrix","text":"1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix","title":"Matrix"},{"location":"tags/#quick-select","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Quick Select"},{"location":"tags/#recursion","text":"203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code","title":"Recursion"},{"location":"tags/#simulation","text":"1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game","title":"Simulation"},{"location":"tags/#sorting","text":"268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 692. Top K Frequent Words","title":"Sorting"},{"location":"tags/#stack","text":"2130. Maximum Twin Sum of a Linked List 682. Baseball Game","title":"Stack"},{"location":"tags/#string","text":"1880. Check if Word Equals Summation of Two Words 2053. Kth Distinct String in an Array 2085 count common words with one occurrence 344. Reverse String 537. Complex Number Multiplication","title":"String"},{"location":"tags/#tree","text":"700. Search in a Binary Search Tree","title":"Tree"},{"location":"tags/#two-pointers","text":"1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays","title":"Two Pointers"},{"location":"tags/#two-pointers_1","text":"2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List","title":"Two pointers"},{"location":"tags/#union-find","text":"200. Number of Islands 695. Max Area of Island","title":"Union Find"}]}