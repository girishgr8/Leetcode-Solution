{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Leetcode problems Getting Started \u00b6 On this website, you will find the solutions to Leetcode problems in Java , C++ and Python along with time & space complexities.","title":"Introduction"},{"location":"#getting-started","text":"On this website, you will find the solutions to Leetcode problems in Java , C++ and Python along with time & space complexities.","title":"Getting Started"},{"location":"tags/","text":"Tags \u00b6 Following is a list of tags: Array \u00b6 1. Two Sum 11. Container With Most Water 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 1980. Find Unique Binary String 200. Number of Islands 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 216. Combination Sum III 268. Missing Number 322. Coin Change 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 40. Combination Sum II 42. Trapping Rain Water 46. Permutations 51. N-Queens 56. Merge Intervals 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 63. Unique Paths II 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 75. Sort Colors 931. Minimum Falling Path Sum Backtracking \u00b6 1980. Find Unique Binary String 216. Combination Sum III 40. Combination Sum II 46. Permutations 51. N-Queens 77. Combinations 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences Binary Search \u00b6 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix Binary Search Tree \u00b6 230. Kth Smallest Element in a BST 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Binary Tree \u00b6 100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Bit Manipulation \u00b6 268. Missing Number Breadth-First Search \u00b6 100. Same Tree 200. Number of Islands 322. Coin Change 513. Find Bottom Left Tree Value 695. Max Area of Island 75. Sort Colors 785. Is Graph Bipartite? 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences Bucket Sort \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Combinatorics \u00b6 62. Unique Paths Counting \u00b6 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 347. Top K Frequent Elements 692. Top K Frequent Words Depth-First Search \u00b6 100. Same Tree 200. Number of Islands 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 695. Max Area of Island 785. Is Graph Bipartite? 797. All Paths From Source to Target 897. Increasing Order Search Tree Divide and Conquer \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Dynamic Programming \u00b6 1092. Shortest Common Supersequence 1143. Longest Common Subsequence 322. Coin Change 392. Is Subsequence 42. Trapping Rain Water 516. Longest Palindromic Subsequence 62. Unique Paths 63. Unique Paths II 75. Sort Colors 931. Minimum Falling Path Sum Graph \u00b6 785. Is Graph Bipartite? 797. All Paths From Source to Target Greedy \u00b6 11. Container With Most Water 2224. Minimum Number of Operations to Convert Time Hash Table \u00b6 1. Two Sum 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 692. Top K Frequent Words 73. Set Matrix Zeroes Heap (Priority Queue) \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Linked List \u00b6 1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List Math \u00b6 268. Missing Number 537. Complex Number Multiplication 62. Unique Paths Matrix \u00b6 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 63. Unique Paths II 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 931. Minimum Falling Path Sum Monotonic Stack \u00b6 42. Trapping Rain Water Quick Select \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Recursion \u00b6 203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code Simulation \u00b6 1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game Sorting \u00b6 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 56. Merge Intervals 594. Longest Harmonious Subsequence 692. Top K Frequent Words Stack \u00b6 2130. Maximum Twin Sum of a Linked List 42. Trapping Rain Water 682. Baseball Game 897. Increasing Order Search Tree String \u00b6 1092. Shortest Common Supersequence 1143. Longest Common Subsequence 1880. Check if Word Equals Summation of Two Words 1980. Find Unique Binary String 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 2224. Minimum Number of Operations to Convert Time 344. Reverse String 392. Is Subsequence 516. Longest Palindromic Subsequence 537. Complex Number Multiplication 609. Find Duplicate File in System Tree \u00b6 100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Two Pointers \u00b6 11. Container With Most Water 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays 392. Is Subsequence 42. Trapping Rain Water Two pointers \u00b6 2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List Union Find \u00b6 200. Number of Islands 695. Max Area of Island 785. Is Graph Bipartite?","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of tags:","title":"Tags"},{"location":"tags/#array","text":"1. Two Sum 11. Container With Most Water 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 1980. Find Unique Binary String 200. Number of Islands 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 216. Combination Sum III 268. Missing Number 322. Coin Change 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 40. Combination Sum II 42. Trapping Rain Water 46. Permutations 51. N-Queens 56. Merge Intervals 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 63. Unique Paths II 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 75. Sort Colors 931. Minimum Falling Path Sum","title":"Array"},{"location":"tags/#backtracking","text":"1980. Find Unique Binary String 216. Combination Sum III 40. Combination Sum II 46. Permutations 51. N-Queens 77. Combinations 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences","title":"Backtracking"},{"location":"tags/#binary-search","text":"1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix","title":"Binary Search"},{"location":"tags/#binary-search-tree","text":"230. Kth Smallest Element in a BST 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Binary Search Tree"},{"location":"tags/#binary-tree","text":"100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Binary Tree"},{"location":"tags/#bit-manipulation","text":"268. Missing Number","title":"Bit Manipulation"},{"location":"tags/#breadth-first-search","text":"100. Same Tree 200. Number of Islands 322. Coin Change 513. Find Bottom Left Tree Value 695. Max Area of Island 75. Sort Colors 785. Is Graph Bipartite? 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences","title":"Breadth-First Search"},{"location":"tags/#bucket-sort","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Bucket Sort"},{"location":"tags/#combinatorics","text":"62. Unique Paths","title":"Combinatorics"},{"location":"tags/#counting","text":"2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 347. Top K Frequent Elements 692. Top K Frequent Words","title":"Counting"},{"location":"tags/#depth-first-search","text":"100. Same Tree 200. Number of Islands 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 695. Max Area of Island 785. Is Graph Bipartite? 797. All Paths From Source to Target 897. Increasing Order Search Tree","title":"Depth-First Search"},{"location":"tags/#divide-and-conquer","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Divide and Conquer"},{"location":"tags/#dynamic-programming","text":"1092. Shortest Common Supersequence 1143. Longest Common Subsequence 322. Coin Change 392. Is Subsequence 42. Trapping Rain Water 516. Longest Palindromic Subsequence 62. Unique Paths 63. Unique Paths II 75. Sort Colors 931. Minimum Falling Path Sum","title":"Dynamic Programming"},{"location":"tags/#graph","text":"785. Is Graph Bipartite? 797. All Paths From Source to Target","title":"Graph"},{"location":"tags/#greedy","text":"11. Container With Most Water 2224. Minimum Number of Operations to Convert Time","title":"Greedy"},{"location":"tags/#hash-table","text":"1. Two Sum 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 692. Top K Frequent Words 73. Set Matrix Zeroes","title":"Hash Table"},{"location":"tags/#heap-priority-queue","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Heap (Priority Queue)"},{"location":"tags/#linked-list","text":"1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List","title":"Linked List"},{"location":"tags/#math","text":"268. Missing Number 537. Complex Number Multiplication 62. Unique Paths","title":"Math"},{"location":"tags/#matrix","text":"1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 63. Unique Paths II 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 931. Minimum Falling Path Sum","title":"Matrix"},{"location":"tags/#monotonic-stack","text":"42. Trapping Rain Water","title":"Monotonic Stack"},{"location":"tags/#quick-select","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Quick Select"},{"location":"tags/#recursion","text":"203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code","title":"Recursion"},{"location":"tags/#simulation","text":"1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game","title":"Simulation"},{"location":"tags/#sorting","text":"268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 56. Merge Intervals 594. Longest Harmonious Subsequence 692. Top K Frequent Words","title":"Sorting"},{"location":"tags/#stack","text":"2130. Maximum Twin Sum of a Linked List 42. Trapping Rain Water 682. Baseball Game 897. Increasing Order Search Tree","title":"Stack"},{"location":"tags/#string","text":"1092. Shortest Common Supersequence 1143. Longest Common Subsequence 1880. Check if Word Equals Summation of Two Words 1980. Find Unique Binary String 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 2224. Minimum Number of Operations to Convert Time 344. Reverse String 392. Is Subsequence 516. Longest Palindromic Subsequence 537. Complex Number Multiplication 609. Find Duplicate File in System","title":"String"},{"location":"tags/#tree","text":"100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Tree"},{"location":"tags/#two-pointers","text":"11. Container With Most Water 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays 392. Is Subsequence 42. Trapping Rain Water","title":"Two Pointers"},{"location":"tags/#two-pointers_1","text":"2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List","title":"Two pointers"},{"location":"tags/#union-find","text":"200. Number of Islands 695. Max Area of Island 785. Is Graph Bipartite?","title":"Union Find"},{"location":"dp/01knapsack/","text":"Approach 1 : Recursion Java Time Complexity : O(2^(n*W)) where n is number of items, and W is the capacity of knapsack Space Complexity : O(max(n,W)) where n is number of items, and W is the capacity of knapsack Approach 2 : Memoization Java Time Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack Space Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack Approach 3 : Tabulation Java class Solution { public static void main ( String [] args ) { int W = 50 ; int n = 3 ; int [] p = { 60 , 100 , 120 }; int [] wt = { 10 , 20 , 30 }; int [][] dp = new int [ n + 1 ][ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ){ for ( int j = 0 ; j <= W ; j ++ ){ if ( i == 0 || j == 0 ) continue ; else if ( wt [ i - 1 ] > j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , ( dp [ i - 1 ][ j - wt [ i - 1 ]]+ p [ i - 1 ] )); } } System . out . println ( \"Maximum Profit = \" + dp [ n ][ W ] ); } } Time Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack Space Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack","title":"0/1 Knapsack"},{"location":"dp/lcs/","text":"Approach 1 : Recursion Java class Solution { public static void main ( String [] args ) { String s1 = \"AGGTAB\" , s2 = \"GXTXAYB\" ; int m = s1 . length (), n = s2 . length (); int lcs = solve ( m - 1 , n - 1 , s1 , s2 ); System . out . println ( \"Length of LCS = \" + lcs ); } public static int solve ( int i , int j , String s1 , String s2 ){ // base case if ( i < 0 || j < 0 ) return 0 ; // if the current characters of both strings match, // then lcs length = 1 + lcs length for remaining part of these strings if ( s1 . charAt ( i ) == s2 . charAt ( j )) return 1 + solve ( i - 1 , j - 1 , s1 , s2 ); return Math . max ( solve ( i - 1 , j , s1 , s2 ), solve ( i , j - 1 , s1 , s2 )); } } Time Complexity : O(2 m*n ) where m and n are the length of the two strings Space Complexity : O(max(m,n)) where m and n are the length of the two strings Approach 2 : Memoization Java Time Complexity : O(m*n) where m and n are the length of the two strings Space Complexity : O(m*n) where m and n are the length of the two strings Approach 3 : Tabulation Java class Solution { public static void main ( String [] args ) { String s1 = \"ABCDGH\" , s2 = \"AEDFHR\" ; int m = s1 . length (), n = s2 . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ){ for ( int j = 0 ; j < n + 1 ; j ++ ){ if ( i == 0 || j == 0 ) dp [ i ][ j ] = 0 ; else if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } int lcs = dp [ m ][ n ] ; System . out . println ( \"Length of LCS : \" + dp [ m ][ n ] ); char [] str = new char [ lcs ] ; int i = m , j = n ; while ( i > 0 && j > 0 ){ if ( dp [ i - 1 ][ j ] == dp [ i ][ j ] ) i -- ; else if ( dp [ i ][ j - 1 ] == dp [ i ][ j ] ) j -- ; else { str [-- lcs ] = s1 . charAt ( i - 1 ); i -- ; j -- ; } } System . out . println ( \"LCS is : \" + String . valueOf ( str )); } } Time Complexity : O(m*n) where m and n are the length of the two strings Space Complexity : O(m*n) where m and n are the length of the two strings","title":"Longest Common Subsequence(LCS)"},{"location":"dp/lps/","text":"Basically, the idea is to find length of LCS of a string and it's reverse Approach 1 : Recursion Java class Solution { public static void main ( String [] args ) { String s1 = \"\" ; String s2 = new StringBuilder ( s1 ). reverse (). toString (); int n = s1 . length (); int lps = solve ( n - 1 , n - 1 , s1 , s2 ); System . out . println ( \"Length of LPS = \" + lps ); } public static int solve ( int i , int j , String s1 , String s2 ){ // base case if ( i < 0 || j < 0 ) return 0 ; // if the current characters of both strings match, // then lcs length = 1 + lcs length for remaining part of these strings if ( s1 . charAt ( i ) == s2 . charAt ( j )) return 1 + solve ( i - 1 , j - 1 , s1 , s2 ); return Math . max ( solve ( i - 1 , j , s1 , s2 ), solve ( i , j - 1 , s1 , s2 )); } } Time Complexity : O(2 n*n ) where n is the length of the string Space Complexity : O(n) where n is the length of the string Approach 2 : Memoization Java Time Complexity : O(n 2 ) where n is the length of the string Space Complexity : O(n 2 ) where n is the length of the string Approach 3 : Tabulation Java class Solution { public static void main ( String [] args ) { String s1 = \"\" ; String s2 = new StringBuilder ( s1 ). reverse (). toString (); int n = s1 . length (); int [][] dp = new int [ n + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ){ if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } System . out . println ( \"Length of LPS = \" + dp [ n ][ n ] ); } } Time Complexity : O(n 2 ) where n is the length of the string Space Complexity : O(n 2 ) where n is the length of the string","title":"Longest Palindromic Subsequence(LPS)"},{"location":"dp/mincoinchange/","text":"Approach 1 : Recursion Java class Solution { public static void main ( String [] args ) { int [] coins = { 1 , 5 , 7 }; int n = 18 ; int minCoins = solve ( n , coins ); System . out . println ( \"To make a change of \" + n + \", minimum coins needed are \" + minCoins ); } public static int solve ( int n , int [] coins ){ if ( n == 0 ) return 0 ; int minimum = Integer . MAX_VALUE ; for ( int i = 0 ; i < coins . length ; i ++ ){ if ( n - coins [ i ] >= 0 ){ int subMin = solve ( n - coins [ i ] , coins ); if ( subMin != Integer . MAX_VALUE && subMin + 1 < minimum ) minimum = 1 + subMin ; } } return minimum ; } } Time Complexity : O(2^(n*V)) where n is number of different coins, and V is the change to make Space Complexity : O(max(n,V)) where n is number of different coins, and V is the change to make Approach 3 : Tabulation Java class Solution { public static void main ( String [] args ) { int [] coins = { 1 , 5 , 7 }; int n = 14 ; int totalCoins = coins . length ; int [] dp = new int [ n + 1 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ); dp [ 0 ] = 0 ; for ( int i = 1 ; i < dp . length ; i ++ ){ for ( int j = 0 ; j < totalCoins ; j ++ ){ if ( coins [ j ] <= i ){ int min = dp [ i - coins [ j ]] ; if ( min != Integer . MAX_VALUE && min + 1 < dp [ i ] ) dp [ i ] = min + 1 ; } } } int minCoins = dp [ n ] ; if ( minCoins != Integer . MAX_VALUE ) System . out . println ( \"To make a change of \" + n + \", minimum coins needed are \" + minCoins ); else System . out . println ( \"We cannot make a change of \" + n + \" using given coins\" ); } } Time Complexity : O(n*V) where n is number of different coins, and V is the change to make Space Complexity : O(n*V) where n is number of different coins, and V is the change to make","title":"Coin Change - minimum number of coins to make the change"},{"location":"problems/1-two-sum/","tags":["Array","Hash Table"],"text":"Leetcode Problem Link : https://leetcode.com/problems/two-sum/ Approach 1 : Brute Force Java C++ class Solution { public int [] twoSum ( int [] nums , int target ) { int n = nums . length ; for ( int i = 0 ; i < n ; i ++ ){ for ( int j = i + 1 ; j < n ; j ++ ) if ( nums [ i ] + nums [ j ] == target ) return new int [] { i , j }; } return new int [] { - 1 , - 1 }; } } class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { int n = nums . size (); for ( int i = 0 ; i < n ; i ++ ){ for ( int j = i + 1 ; j < n ; j ++ ) if ( nums [ i ] + nums [ j ] == target ) return { i , j }; } return { -1 , -1 }; } }; Time Complexity : O(n 2 ) where n is the length of array Space Complexity : O(1) Approach 2 : HashTable Approach Java public class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > (); for ( int i = 0 ; i < nums . length ; i ++ ){ int n1 = nums [ i ] ; int n2 = target - n1 ; if ( map . containsKey ( n2 )){ int result [] = new int [] { map . get ( n2 ), i }; return result ; } map . put ( nums [ i ] , i ); } return new int [ 2 ] ; } } Time Complexity : O(n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"1. Two Sum"},{"location":"problems/100-same-tree/","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/same-tree/ Approach 1 : Recursive Approach Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) return true ; if ( p == null || q == null ) return false ; if ( p . val != q . val ) return false ; return ( isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right )); } } Time Complexity : O(n) where n = number of nodes in tree Space Complexity : O(h) where h = height of tree Approach 2 : Iterative Approach Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { Queue < TreeNode > queue = new LinkedList <> (); if ( p == null && q == null ) return true ; else if ( p == null || q == null ) return false ; if ( p != null && q != null ) { queue . add ( p ); queue . add ( q ); } while ( ! queue . isEmpty ()) { TreeNode first = queue . poll (); TreeNode second = queue . poll (); if ( first == null && second == null ) continue ; if ( first == null || second == null ) return false ; if ( first . val != second . val ) return false ; queue . add ( first . left ); queue . add ( second . left ); queue . add ( first . right ); queue . add ( second . right ); } return true ; } } Time Complexity : O(n) where n = number of nodes in tree Space Complexity : O(h) where h = height of tree","title":"100. Same Tree"},{"location":"problems/1092-shortest-common-supersequence/","tags":["String","Dynamic Programming"],"text":"Leetcode Problem Link : https://leetcode.com/problems/shortest-common-supersequence/ Approach : Dynamic Programming - Tabulation Java C++ class Solution { public String shortestCommonSupersequence ( String str1 , String str2 ) { int m = str1 . length (), n = str2 . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ){ if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } int lenLCS = dp [ m ][ n ] ; int size = m + n - lenLCS ; char [] scs = new char [ size ] ; int i = m , j = n ; while ( i > 0 && j > 0 ){ if ( dp [ i - 1 ][ j ] == dp [ i ][ j ] ) scs [-- size ] = str1 . charAt ( -- i ); else if ( dp [ i ][ j - 1 ] == dp [ i ][ j ] ) scs [-- size ] = str2 . charAt ( -- j ); else { scs [-- size ] = str1 . charAt ( i - 1 ); i -- ; j -- ; } } while ( i > 0 ) scs [-- size ] = str1 . charAt ( -- i ); while ( j > 0 ) scs [-- size ] = str2 . charAt ( -- j ); return String . valueOf ( scs ); } } Time Complexity : O(m*n) where m & n are length of strings str1 and str2 Space Complexity : O(m*n) where m & n are length of strings str1 and str2","title":"1092. Shortest Common Supersequence"},{"location":"problems/11-container-with-most-water/","tags":["Array","Two Pointers","Greedy"],"text":"Leetcode Problem Link : https://leetcode.com/problems/container-with-most-water/ Approach 1 : Brute Force Java class Solution { public int maxArea ( int [] height ) { int n = height . length ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ){ for ( int j = i + 1 ; j < n ; j ++ ){ int x = j - i ; int y = Math . min ( height [ i ] , height [ j ] ); max = Math . max ( max , x * y ); } } return max ; } } Time Complexity : O(n 2 ) where n is the length of array Space Complexity : O(1) Approach 2 : Two Pointers Java class Solution { public int maxArea ( int [] height ) { int n = height . length ; int left = 0 , right = n - 1 ; int max = 0 ; while ( left < right ){ int x = right - left ; int y = Math . min ( height [ left ] , height [ right ] ); max = Math . max ( max , x * y ); if ( height [ left ] < height [ right ] ) left ++ ; else right -- ; } return max ; } } Time Complexity : O(n) where n is the length of array Space Complexity : O(1)","title":"11. Container With Most Water"},{"location":"problems/1143-longest-common-subsequence/","tags":["String","Dynamic Programming"],"text":"Leetcode Problem Link : https://leetcode.com/problems/longest-common-subsequence/ Approach 1 : Brute Force - Recursion Java C++ class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { return LCS ( text1 , text2 , text1 . length (), text2 . length ()); } public int LCS ( String s1 , String s2 , int i , int j ){ if ( i == 0 || j == 0 ) return 0 ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) return 1 + LCS ( s1 , s2 , i - 1 , j - 1 ); else return Math . max ( LCS ( s1 , s2 , i - 1 , j ), LCS ( s1 , s2 , i , j - 1 )); } } Time Complexity : O(2^(m*n)) where m & n are length of strings text1 and text2 Space Complexity : O(max(m,n)) where m & n are length of strings text1 and text2 Approach 2 : Dynamic Programming - Memoization Java C++ class Solution { int [][] dp ; public int longestCommonSubsequence ( String text1 , String text2 ) { int m = text1 . length (), n = text2 . length (); dp = new int [ m + 1 ][ n + 1 ] ; return LCS ( text1 , text2 , m , n ); } public int LCS ( String s1 , String s2 , int i , int j ){ if ( i == 0 || j == 0 ) return 0 ; if ( dp [ i ][ j ] != 0 ) return dp [ i ][ j ] ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + LCS ( s1 , s2 , i - 1 , j - 1 ); else dp [ i ][ j ] = Math . max ( LCS ( s1 , s2 , i - 1 , j ), LCS ( s1 , s2 , i , j - 1 )); return dp [ i ][ j ] ; } } Time Complexity : O(m*n) where m & n are length of strings text1 and text2 Space Complexity : O(m*n) where m & n are length of strings text1 and text2 Approach 3 : Dynamic Programming - Tabulation Java C++ class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { int m = text1 . length (), n = text2 . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ){ if ( text1 . charAt ( i - 1 ) == text2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } return dp [ m ][ n ] ; } } Time Complexity : O(m*n) where m & n are length of strings text1 and text2 Space Complexity : O(m*n) where m & n are length of strings text1 and text2","title":"1143. Longest Common Subsequence"},{"location":"problems/1222-queens-that-can-attack-the-king/","tags":["Array","Matrix","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/queens-that-can-attack-the-king/ Approach : Matrix Exploration + Simulation Java C++ class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [][] board = new boolean [ 8 ][ 8 ] ; for ( int i = 0 ; i < queens . length ; i ++ ) board [ queens [ i ][ 0 ]][ queens [ i ][ 1 ]] = true ; int [] dir = { 1 , 0 , - 1 }; for ( int dx : dir ){ for ( int dy : dir ){ if ( dx == 0 && dy == 0 ) continue ; int x = king [ 0 ] ; int y = king [ 1 ] ; while ( x + dx >= 0 && x + dx < 8 && y + dy >= 0 && y + dy < 8 ){ x += dx ; y += dy ; if ( board [ x ][ y ] ){ result . add ( Arrays . asList ( x , y )); break ; } } } } return result ; } } Time Complexity : O(1) i.e. O(8*8) as it is a 8*8 chessboard Space Complexity : O(1) i.e. O(8*8) as it is a 8*8 chessboard","title":"1222. Queens That Can Attack the King"},{"location":"problems/1351-count-negative-numbers-in-a-sorted-matrix/","tags":["Array","Binary Search","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/ Approach 1 : Brute Force Approach Java C++ class Solution { public int countNegatives ( int [][] grid ) { int count = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ){ for ( int j = 0 ; j < grid [ i ] . length ; j ++ ){ if ( grid [ i ][ j ] < 0 ) count ++ ; } } return count ; } } class Solution { public : int countNegatives ( vector < vector < int >>& grid ) { int count = 0 ; for ( int i = 0 ; i < grid . size (); i ++ ){ for ( int j = 0 ; j < grid [ i ]. size (); j ++ ){ if ( grid [ i ][ j ] < 0 ) count ++ ; } } return count ; } }; Time Complexity : O(m*n) where (m,n) is the dimension of the grid Space Complexity : O(1) Approach 2 : Binary Search (on each row) Java C++ class Solution { public int countNegatives ( int [][] grid ) { int count = 0 ; // m = no. of rows, n = no. of columns int m = grid . length , n = grid [ 0 ] . length ; for ( int i = 0 ; i < grid . length ; i ++ ){ int low = 0 , high = n - 1 ; // Apply Binary Search on each row while ( low <= high ){ int mid = low + ( high - low ) / 2 ; // If the number at 'mid' is -ve, // that means all the numbers to its right will also be -ve // So count them and solve for left part if ( grid [ i ][ mid ] < 0 ){ count += high - mid + 1 ; high = mid - 1 ; } // Otherwise, check if -ve number is present on right part else { low = mid + 1 ; } } } return count ; } } class Solution { public : int countNegatives ( int [][] grid ) { int count = 0 ; int m = grid . length , n = grid [ 0 ]. length ; for ( int i = 0 ; i < grid . length ; i ++ ){ int low = 0 , high = n - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( grid [ i ][ mid ] < 0 ){ count += high - mid + 1 ; high = mid - 1 ; } else { low = mid + 1 ; } } } return count ; } }; Time Complexity : O(m*log 2 n) where m = number of rows & n = number of columns Space Complexity : O(1)","title":"1351. Count Negative Numbers in a Sorted Matrix"},{"location":"problems/153-find-minimum-in-rotated-sorted-array/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Approach 1 : Linear Search Java class Solution { public int findMin ( int [] nums ) { int n = nums . length ; if ( n == 1 ) return nums [ 0 ] ; // No rotations at all if ( nums [ 0 ] <= nums [ n - 1 ] ) return nums [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ){ int prev = ( i + n - 1 ) % n ; int next = ( i + 1 ) % n ; if ( nums [ i ] <= nums [ prev ] && nums [ i ] <= nums [ next ] ) return nums [ i ] ; } return nums [ 0 ] ; } } Time Complexity : O(n) where n are the length of the array Space Complexity : O(1) Approach 2 : Modified Binary Search(Iterative) Java class Solution { public int findMin ( int [] nums ) { int n = nums . length ; int low = 0 , high = n - 1 ; while ( low <= high ){ // when array is already sorted if ( nums [ low ] <= nums [ high ] ) return nums [ low ] ; int mid = low + ( high - low ) / 2 ; int next = ( mid + 1 ) % n ; int prev = ( mid + n - 1 ) % n ; // The minimum element has special characteristic in rotated array // that it is less than elements to its left and to its right if ( nums [ mid ] <= nums [ prev ] && nums [ mid ] <= nums [ next ] ) return nums [ mid ] ; // if the nums[low] <= nums[mid], // it means the subarray to left of mid is sorted // so minimum element lies in right subarray of mid else if ( nums [ low ] <= nums [ mid ] ) low = mid + 1 ; // if the nums[mid] <= nums[high], // it means the subarray to right of mid is sorted // so minimum element lies in left subarray of mid else if ( nums [ mid ] <= nums [ high ] ) high = mid - 1 ; } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(1) Approach 3: Modified Binary Search(Recursive) Java class Solution { public int findMin ( int [] nums ) { return search ( nums , 0 , nums . length - 1 ); } public int search ( int nums [] , int low , int high ){ int n = nums . length ; if ( low <= high ){ // when array is already sorted if ( nums [ low ] <= nums [ high ] ) return nums [ low ] ; int mid = low + ( high - low ) / 2 ; int next = ( mid + 1 ) % n ; int prev = ( mid + n - 1 ) % n ; // The minimum element has special characteristic in rotated array // that it is less than elements to its left and to its right if ( nums [ mid ] <= nums [ prev ] && nums [ mid ] <= nums [ next ] ) return nums [ mid ] ; // if the nums[low] <= nums[mid], // it means the subarray to left of mid is sorted // so minimum element lies in right subarray of mid else if ( nums [ low ] <= nums [ mid ] ) return search ( nums , mid + 1 , high ); // if the nums[mid] <= nums[high], // it means the subarray to right of mid is sorted // so minimum element lies in left subarray of mid else if ( nums [ mid ] <= nums [ high ] ) return search ( nums , low , mid - 1 ); } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(log n) where n are the length of the array","title":"153. Find Minimum in Rotated Sorted Array"},{"location":"problems/1539-kth-missing-positive-number/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-missing-positive-number/ Approach : Modified Binary Search Java C++ class Solution { public int findKthPositive ( int [] arr , int k ) { int low = 0 , high = arr . length ; while ( low < high ){ int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] - mid - 1 < k ) low = mid + 1 ; else high = mid ; } return high + k ; } } Time Complexity : O(log n) where n = number of elements in array Space Complexity : O(1)","title":"1539. Kth Missing Positive Number"},{"location":"problems/1721-swapping-nodes-in-a-linked-list/","tags":["Linked List","Two Pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ Approach 1 : Simple & Intuitive approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapNodes ( ListNode head , int k ) { int n = 0 , curr = 0 ; ListNode ptr = head ; ListNode begin = head , end = head ; while ( ptr != null ){ ptr = ptr . next ; n ++ ; } ptr = head ; while ( ptr != null ){ if ( n - curr == k ) end = ptr ; curr ++ ; if ( curr == k ) begin = ptr ; ptr = ptr . next ; } int temp = begin . val ; begin . val = end . val ; end . val = temp ; return head ; } } Time Complexity : O(n) where n = number of nodes in linked list Space Complexity : O(1) Approach 2 : Slow - Fast Pointers Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapNodes ( ListNode head , int k ) { ListNode dummy = new ListNode ( 0 , head ); ListNode fast = dummy , slow = dummy ; ListNode tempNode = null ; while ( k -- > 0 ) fast = fast . next ; tempNode = fast ; while ( fast != null ) { fast = fast . next ; slow = slow . next ; } int temp = slow . val ; slow . val = tempNode . val ; tempNode . val = temp ; return dummy . next ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * swapNodes ( ListNode * head , int k ) { ListNode * dummy = new ListNode ( 0 , head ); ListNode * fast = dummy , * slow = dummy ; ListNode * tempNode = NULL ; while ( k -- > 0 ) fast = fast -> next ; tempNode = fast ; while ( fast != NULL ) { fast = fast -> next ; slow = slow -> next ; } int temp = slow -> val ; slow -> val = tempNode -> val ; tempNode -> val = temp ; return dummy -> next ; } }; Time Complexity : O(n) where n = number of nodes in linked list Space Complexity : O(1)","title":"1721. Swapping Nodes in a Linked List"},{"location":"problems/1773-count-items-matching-a-rule/","text":"Leetcode Problem Link : https://leetcode.com/problems/count-items-matching-a-rule/ Java class Solution { public int countMatches ( List < List < String >> items , String ruleKey , String ruleValue ) { int key = ruleKey . equals ( \"type\" ) ? 0 : ( ruleKey . equals ( \"color\" ) ? 1 : 2 ); int size = items . size (); int count = 0 ; for ( int i = 0 ; i < size ; i ++ ){ if ( items . get ( i ). get ( key ). equals ( ruleValue )) count ++ ; } return count ; } } Time Complexity : O(n) where n is the number of items Space Complexity : O(1)","title":"1773. Count Items Matching a Rule"},{"location":"problems/1880-check-if-word-equals-summation-of-two-words/","tags":["String"],"text":"Leetcode Problem Link : https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/ Approach : Formula Simulation Java C++ class Solution { public boolean isSumEqual ( String firstWord , String secondWord , String targetWord ) { int val1 = findValue ( firstWord ); int val2 = findValue ( secondWord ); int val3 = findValue ( targetWord ); return (( val1 + val2 ) == val3 ); } public int findValue ( String word ){ int val = 0 ; for ( int i = 0 ; i < word . length (); i ++ ) val = 10 * val + ( word . charAt ( i ) - 'a' ); return val ; } } Time Complexity : O(1) as each word's length is maximum 8 characters Space Complexity : O(1)","title":"1880. Check if Word Equals Summation of Two Words"},{"location":"problems/1980-find-unique-binary-string/","tags":["Array","String","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-unique-binary-string/ Approach 1 : Backtracking Java C++ class Solution { boolean solve = true ; String answer = \"\" ; public String findDifferentBinaryString ( String [] nums ) { int n = nums . length ; int bits = nums [ 0 ] . length (); Set < String > strings = Arrays . stream ( nums ). collect ( Collectors . toSet ()); generate ( strings , bits , new ArrayList < Integer > ()); return answer ; } public void generate ( Set < String > strings , int bits , List < Integer > list ){ if ( ! solve ) return ; if ( bits == 0 ){ StringBuilder sb = new StringBuilder (); for ( Integer b : list ) sb . append ( b ); answer = sb . toString (); if ( ! strings . contains ( answer )) solve = false ; return ; } if ( ! solve ) return ; for ( int i = 0 ; i < 2 ; i ++ ){ list . add ( i ); generate ( strings , bits - 1 , list ); list . remove ( new Integer ( i )); } } } Time Complexity : Space Complexity : Approach 2 : Using proof of Cantor's Diagonal Argument To generate missing string, take complement of i th bit from i th string. This trick can be used since the length of array and number of bits in each string are same. Java class Solution { public String findDifferentBinaryString ( String [] nums ) { int n = nums . length ; StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < n ; i ++ ) sb . append ( nums [ i ] . charAt ( i ) == '1' ? '0' : '1' ); return sb . toString (); } }","title":"1980. Find Unique Binary String"},{"location":"problems/2-add-two-numbers/","text":"C++ Java class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( l1 || l2 || carry ) { if ( l1 ) { carry += l1 -> val ; l1 = l1 -> next ; } if ( l2 ) { carry += l2 -> val ; l2 = l2 -> next ; } curr -> next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr -> next ; } return dummy . next ; } }; class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { if ( l1 == null ) return l2 ; if ( l2 == null ) return l1 ; ListNode head = l1 , prev = null ; int carry = 0 ; while ( l1 != null && l2 != null ){ int sum = l1 . val + l2 . val + carry ; carry = sum / 10 ; l1 . val = sum % 10 ; prev = l1 ; l1 = l1 . next ; l2 = l2 . next ; } while ( l1 != null ){ int sum = l1 . val + carry ; carry = sum / 10 ; l1 . val = sum % 10 ; prev = l1 ; l1 = l1 . next ; } while ( l2 != null ){ int sum = l2 . val + carry ; carry = sum / 10 ; ListNode newnode = new ListNode ( sum % 10 ); prev . next = newnode ; prev = newnode ; l2 = l2 . next ; } if ( carry > 0 ){ ListNode newnode = new ListNode ( carry ); newnode . next = null ; prev . next = newnode ; } return head ; } }","title":"2. Add Two Numbers"},{"location":"problems/200-number-of-islands/","tags":["Array","Depth-First Search","Breadth-First Search","Union Find","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/number-of-islands/ Approach : DFS Java C++ class Solution { boolean [][] visited ; public int numIslands ( char [][] grid ) { int m = grid . length , n = grid [ 0 ] . length ; visited = new boolean [ m ][ n ] ; int islands = 0 ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( grid [ i ][ j ] == '1' && ! visited [ i ][ j ] ) islands += explore ( grid , m , n , i , j ); } } return islands ; } public int explore ( char [][] grid , int m , int n , int row , int col ){ // base case 1: if we go out of bounds of the matrix if ( row < 0 || col < 0 || row >= m || col >= n ) return 0 ; // base case 2: if we are not currently at island (grid[i][j] == '0') // or we have already visited this island if ( grid [ row ][ col ] == '0' || visited [ row ][ col ] ) return 0 ; // visit the current island visited [ row ][ col ] = true ; // recursively visit islands to left, right, above below int left = explore ( grid , m , n , row , col - 1 ); int right = explore ( grid , m , n , row , col + 1 ); int above = explore ( grid , m , n , row - 1 , col ); int below = explore ( grid , m , n , row + 1 , col ); return 1 ; } } Time Complexity : O(m*n) where m = numeber of rows, n = number of columns Space Complexity : O(m*n) where m = numeber of rows, n = number of columns","title":"200. Number of Islands"},{"location":"problems/203-remove-linked-list-elements/","tags":["Linked List","Recursion"],"text":"Leetcode Problem Link : https://leetcode.com/problems/remove-linked-list-elements/ Approach 1 : Recursive Approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements ( ListNode head , int val ) { // Base case if ( head == null ) return head ; // Recursively remove nodes with value 'val' from the list ListNode node = removeElements ( head . next , val ); // if the head's val == val, then return the other part of the list if ( head . val == val ) return node ; // otherwise, head.next will point to list returned after solving recursively for rest part head . next = node ; return head ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { // Base case if ( ! head ) return head ; // Recursively remove nodes with value 'val' from the list ListNode * node = removeElements ( head -> next , val ); // if the head's val == val, then return the other part of the list if ( head -> val == val ) return node ; // otherwise, head.next will point to list returned after solving recursively for rest part head -> next = node ; return head ; } }; Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1) Approach 2 : Iterative Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements ( ListNode head , int val ) { if ( head == null ) return head ; ListNode prev = null , curr = head ; while ( curr != null ){ if ( curr . val == val ){ if ( prev == null ) head = curr . next ; else prev . next = curr . next ; } else prev = curr ; curr = curr . next ; } return head ; } } Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1)","title":"203. Remove Linked List Elements"},{"location":"problems/2053-kth-distinct-string-in-an-array/","tags":["Array","Hash Table","String","Counting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-distinct-string-in-an-array/ Approach : HashMap Java C++ class Solution { public String kthDistinct ( String [] arr , int k ) { Map < String , Integer > map = new LinkedHashMap < String , Integer > (); for ( String str : arr ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); int i = 0 ; for ( String word : arr ){ if ( map . getOrDefault ( word , 0 ) == 1 && ++ i == k ) return word ; } return \"\" ; } } Time Complexity : O(n) where n = size of array Space Complexity : O(n1 + n2) where n = size of array","title":"2053. Kth Distinct String in an Array"},{"location":"problems/206-reverse-linked-list/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/reverse-linked-list/ Approach 1 : Recursive approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) { return head ; } ListNode node = reverseList ( head . next ); head . next . next = head ; head . next = null ; return node ; } } Time Complexity : O(n) where n is number of nodes in linked list Space Complexity : O(1) Approach 2 : Iterative approach Java C++ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null , curr = head , next = null ; while ( curr != null ){ next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * next , * prev = NULL ; while ( head != NULL ) { next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Time Complexity : O(n) where n is number of nodes in linked list Space Complexity : O(1)","title":"206. Reverse Linked List"},{"location":"problems/2085-count-common-words-with-one-occurrence/","tags":["Array","Hash Table","String","Counting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/count-common-words-with-one-occurrence/ Approach : HashMap Java C++ class Solution { public int countWords ( String [] words1 , String [] words2 ) { Map < String , Integer > map1 = new HashMap < String , Integer > (); Map < String , Integer > map2 = new HashMap < String , Integer > (); for ( String word : words1 ) map1 . put ( word , map1 . getOrDefault ( word , 0 ) + 1 ); for ( String word : words2 ) map2 . put ( word , map2 . getOrDefault ( word , 0 ) + 1 ); int unique = 0 ; for ( String word : map1 . keySet ()){ int n1 = map1 . get ( word ); int n2 = map2 . getOrDefault ( word , 0 ); if ( n1 == 1 && n2 == 1 ) unique ++ ; } return unique ; } } Time Complexity : O(n1 + n2) where n1 = size of word1 array, n2 = size of word2 array Space Complexity : O(n1 + n2) where n1 = size of word1 array, n2 = size of word2 array","title":"2085. Count Common Words With One Occurrence"},{"location":"problems/2095-delete-the-middle-node-of-a-linked-list/","tags":["Linked List","Two pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Approach 1 : Naive Approach(Two pass solution) Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteMiddle ( ListNode head ) { if ( head == null || head . next == null ) return null ; int count = 0 ; ListNode ptr = head , prev = null ; while ( ptr != null ){ ptr = ptr . next ; count ++ ; } int mid = count / 2 ; ptr = head ; while ( mid -- > 0 ){ prev = ptr ; ptr = ptr . next ; } prev . next = ptr . next ; return head ; } } Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1) Approach 2 : Two Pointers Approach(One pass solution) Java Python /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteMiddle ( ListNode head ) { if ( head == null || head . next == null ) return null ; ListNode slow = head , fast = head , prev = null ; while ( fast != null && fast . next != null ){ fast = fast . next . next ; prev = slow ; slow = slow . next ; } prev . next = slow . next ; return head ; } } # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def deleteMiddle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if ( head == None or head . next == None ): return None slow , fast , prev = head , head , None while ( fast != None and fast . next != None ): fast = fast . next . next prev = slow slow = slow . next prev . next = slow . next return head Time Complexity : O(n) where n is the length of linked list Space Complexity : O(1)","title":"2095. Delete the Middle Node of a Linked List"},{"location":"problems/21-merge-two-sorted-lists/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/merge-two-sorted-lists/ Approach 1: Recursive approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { // if list1 is empty return list2 if ( list1 == null ) return list2 ; // if list2 is empty return list1 if ( list2 == null ) return list1 ; if ( list1 . val < list2 . val ){ list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; } else { list2 . next = mergeTwoLists ( list1 , list2 . next ); return list2 ; } } } Time Complexity : O(m+n) where m and n are the length of the two lists respectively Space Complexity : O(1) Approach 2: Iterative approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode (); ListNode ptr = dummy ; while ( list1 != null && list2 != null ){ if ( list1 . val < list2 . val ){ ptr . next = list1 ; list1 = list1 . next ; } else { ptr . next = list2 ; list2 = list2 . next ; } ptr = ptr . next ; } if ( list1 == null ) ptr . next = list2 ; if ( list2 == null ) ptr . next = list1 ; return dummy . next ; } } Time Complexity : O(m+n) where m and n are the length of the two lists respectively Space Complexity : O(1)","title":"21. Merge Two Sorted Lists"},{"location":"problems/2130-maximum-twin-sum-of-a-linked-list/","tags":["Linked List","Two pointers","Stack"],"text":"Leetcode Problem Link : https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/ Approach 1 : Two pointers Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public int pairSum ( ListNode head ) { Stack < Integer > stack = new Stack < Integer > (); ListNode slow = head , fast = head ; while ( fast != null && fast . next != null ){ stack . push ( slow . val ); slow = slow . next ; fast = fast . next . next ; } int max = 0 ; while ( slow != null ){ int n1 = stack . pop (); int n2 = slow . val ; max = Math . max ( max ,( n1 + n2 )); slow = slow . next ; } return max ; } } Time Complexity : O(n) where n is the number of nodes in linked list Space Complexity : O(1)","title":"2130. Maximum Twin Sum of a Linked List"},{"location":"problems/216-combination-sum-iii/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/combination-sum-iii/ Approach : Backtracking Java C++ class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> combinationSum3 ( int k , int n ) { int min = k * ( k + 1 ) / 2 ; int max = 9 * ( 9 + 1 ) / 2 ; if ( min > n || max < n ) return result ; for ( int i = 1 ; i <= 9 ; i ++ ){ List < Integer > list = new ArrayList < Integer > (); list . add ( i ); find ( i , k - 1 , n - i , list ); } return result ; } public void find ( int curr , int k , int n , List < Integer > list ){ // base case: // if we used more than 'k' numbers OR their sum has exceeded 'n' if ( n < 0 || k < 0 ) return ; // if 'k' used numbers sum up exactly to 'n' if ( n == 0 && k == 0 ){ result . add ( new ArrayList < Integer > ( list )); return ; } // recursively solve for starting from next number // since we cannot use a number twice for ( int i = curr + 1 ; i <= 9 ; i ++ ){ list . add ( i ); find ( i , k - 1 , n - i , list ); list . remove ( new Integer ( i )); } return ; } } Time Complexity : ~O(1) since the constraints are small Space Complexity : ~O(1) since the constraints are small","title":"216. Combination Sum III"},{"location":"problems/2224-minimum-number-of-operations-to-convert-time/","tags":["String","Greedy"],"text":"Leetcode Problem Link : https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/ Approach : Greedy Java C++ class Solution { public int convertTime ( String current , String correct ) { int operations = 0 ; int currH = Integer . parseInt ( current . split ( \":\" ) [ 0 ] ); int currM = Integer . parseInt ( current . split ( \":\" ) [ 1 ] ); int corrH = Integer . parseInt ( correct . split ( \":\" ) [ 0 ] ); int corrM = Integer . parseInt ( correct . split ( \":\" ) [ 1 ] ); int totCurr = currH * 60 + currM ; int totCorr = corrH * 60 + corrM ; int diff = totCorr - totCurr ; if ( diff >= 60 ){ operations += diff / 60 ; diff %= 60 ; } if ( diff >= 15 ){ operations += diff / 15 ; diff %= 15 ; } if ( diff >= 5 ){ operations += diff / 5 ; diff %= 5 ; } if ( diff >= 1 ) operations += diff ; return operations ; } } Time Complexity : O(1) Space Complexity : O(1)","title":"2224. Minimum Number of Operations to Convert Time"},{"location":"problems/230-kth-smallest-element-in-a-bst/","tags":["Tree","Depth-First Search","Binary Search Tree","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-smallest-element-in-a-bst/ Approach : Recursion Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int smallest = - 1 , count = 0 ; public int kthSmallest ( TreeNode root , int k ) { inorder ( root , k ); return smallest ; } public void inorder ( TreeNode root , int k ){ if ( root == null ) return ; inorder ( root . left , k ); count += 1 ; if ( count == k ){ smallest = root . val ; return ; } inorder ( root . right , k ); } } Time Complexity : O(n) where n = number of nodes in BST Space Complexity : O(n) where n = number of nodes in BST","title":"230. Kth Smallest Element in a BST"},{"location":"problems/268-missing-number/","tags":["Array","Hash Table","Math","Bit Manipulation","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/missing-number/ Approach 1: Sorting & linear search Java C++ class Solution { public int missingNumber ( int [] nums ) { Arrays . sort ( nums ); int n = nums . length ; for ( int i = 0 ; i < n ; i ++ ){ if ( nums [ i ] != i ) return i ; } return n ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int n = nums . size (); for ( int i = 0 ; i < n ; i ++ ){ if ( nums [ i ] != i ) return i ; } return n ; } }; Time Complexity : O(nlogn) where n is length of array Space Complexity : O(1) Approach 2: Using sum of first n natural numbers property Java C++ class Solution { public int missingNumber ( int [] nums ) { int n = nums . length ; int result = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ){ result -= nums [ i ] ; } return result ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int result = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ){ result -= nums [ i ]; } return result ; } }; Time Complexity : O(n) where n is length of array Space Complexity : O(1) Approach 3: Using XOR of the numbers Java C++ class Solution { public int missingNumber ( int [] nums ) { int result = nums . length ; for ( int i = 0 ; i < nums . length ; i ++ ){ result ^= i ; result ^= nums [ i ] ; } return result ; } } class Solution { public : int missingNumber ( vector < int >& nums ) { int result = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ){ result ^= i ; result ^= nums [ i ]; } return result ; } }; Time Complexity : O(n) where n is length of array Space Complexity : O(1)","title":"268. Missing Number"},{"location":"problems/322-coin-change/","tags":["Array","Dynamic Programming","Breadth-First Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/kth-smallest-element-in-a-bst/ Approach 3 : Bottom-Up Approach Java C++ class Solution { public int coinChange ( int [] coins , int amount ) { int [] dp = new int [ amount + 1 ] ; int max = Integer . MAX_VALUE ; Arrays . fill ( dp , max ); dp [ 0 ] = 0 ; for ( int i = 1 ; i < dp . length ; i ++ ){ for ( int j = 0 ; j < coins . length ; j ++ ){ if ( coins [ j ] <= i ){ int min = dp [ i - coins [ j ]] ; if ( min != max && min + 1 < dp [ i ] ) dp [ i ] = min + 1 ; } } } return dp [ amount ] != max ? dp [ amount ] : - 1 ; } } Time Complexity : O(n) where n = number of nodes in BST Space Complexity : O(n) where n = number of nodes in BST","title":"322. Coin Change"},{"location":"problems/34-find-first-and-last-position-of-element-in-sorted-array/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Approach 1 : Linear Search Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = - 1 , lastOccurrence = - 1 ; for ( int i = 0 ; i < nums . length ; i ++ ){ if ( nums [ i ] == target ){ if ( firstOccurrence == - 1 ) firstOccurrence = lastOccurrence = i ; else lastOccurrence = i ; } } return new int [] { firstOccurrence , lastOccurrence }; } } Time Complexity : O(n) where n are the length of the array Space Complexity : O(1) Approach 2 : Modified Binary Search(Recursive) Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = firstBS ( nums , 0 , nums . length - 1 , target ); if ( firstOccurrence != - 1 ){ int lastOccurrence = lastBS ( nums , 0 , nums . length - 1 , target ); return new int [] { firstOccurrence , lastOccurrence }; } return new int [] { - 1 , - 1 }; } public int firstBS ( int nums [] , int low , int high , int target ){ if ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( mid == 0 && nums [ mid ] == target ) return 0 ; if ( nums [ mid ] == target && nums [ mid - 1 ] < target ) return mid ; if ( nums [ mid ] >= target ) return firstBS ( nums , low , mid - 1 , target ); else if ( nums [ mid ] < target ) return firstBS ( nums , mid + 1 , high , target ); } return - 1 ; } public int lastBS ( int nums [] , int low , int high , int target ){ if ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( mid == nums . length - 1 && nums [ mid ] == target ) return mid ; if ( nums [ mid ] == target && nums [ mid + 1 ] > target ) return mid ; if ( nums [ mid ] <= target ) return lastBS ( nums , mid + 1 , high , target ); else if ( nums [ mid ] > target ) return lastBS ( nums , low , mid - 1 , target ); } return - 1 ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(log n) where n are the length of the array Approach 3 : Modified Binary Search(Iterative) Java class Solution { public int [] searchRange ( int [] nums , int target ) { int firstOccurrence = firstBS ( nums , 0 , nums . length - 1 , target ); if ( firstOccurrence != - 1 ){ int lastOccurrence = lastBS ( nums , 0 , nums . length - 1 , target ); return new int [] { firstOccurrence , lastOccurrence }; } return new int [] { - 1 , - 1 }; } public int firstBS ( int nums [] , int low , int high , int target ){ int idx = - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ){ idx = mid ; high = mid - 1 ; } else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return idx ; } public int lastBS ( int nums [] , int low , int high , int target ){ int idx = - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ){ idx = mid ; low = mid + 1 ; } else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return idx ; } } Time Complexity : O(log n) where n are the length of the array Space Complexity : O(1)","title":"34. Find First and Last Position of Element in Sorted Array"},{"location":"problems/344-reverse-string/","tags":["Two Pointers","String","Recursion"],"text":"Leetcode Problem Link : https://leetcode.com/problems/reverse-string/ Approach 1: Recursive Approach Java C++ class Solution { public void reverseString ( char [] s ) { int i = 0 ; int j = s . length - 1 ; helper ( s , i , j ); } public void helper ( char [] s , int i , int j ){ if ( i > j ) return ; char temp = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = temp ; helper ( s , ++ i , -- j ); } } class Solution { public : void reverseString ( vector < char >& s ) { int i = 0 ; int j = s . size () - 1 ; while ( i < j ){ char temp = s [ i ]; s [ i ] = s [ j ]; s [ j ] = temp ; i ++ ; j -- ; } } }; Time Complexity : O(n) where n is the length of string Space Complexity : O(n) where n is the length of string Approach 2: Iterative Approach Java C++ class Solution { public void reverseString ( char [] s ) { int i = 0 , j = s . length - 1 ; while ( i < j ){ char temp = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = t ; i ++ ; j -- ; } } } class Solution { public : void reverseString ( vector < char >& s ) { int i = 0 , j = s . size () - 1 ; while ( i < j ){ char temp = s [ i ]; s [ i ] = s [ j ]; s [ j ] = temp ; i ++ ; j -- ; } } }; Time Complexity : O(n) where n is the length of string Space Complexity : O(1)","title":"344. Reverse String"},{"location":"problems/347-top-k-frequent-elements/","tags":["Array","Hash Table","Divide and Conquer","Sorting","Heap (Priority Queue)","Bucket Sort","Counting","Quick Select"],"text":"Leetcode Problem Link : https://leetcode.com/problems/top-k-frequent-elements/ Approach 1 : Using Heap (PriorityQueue) Java class Element { int freq , element ; public Element ( int element , int freq ) { this . element = element ; this . freq = freq ; } } class Solution { public int [] topKFrequent ( int [] nums , int k ) { // O(1) time if k == nums.length if ( k == nums . length ) return nums ; // create a map to store elements and their frequencies HashMap < Integer , Integer > map = new HashMap < Integer , Integer > (); // Minheap to store the top 'k' frequent elements PriorityQueue < Element > heap = new PriorityQueue < Element > (( e1 , e2 ) -> e1 . freq - e2 . freq ); for ( int i = 0 ; i < nums . length ; i ++ ) map . put ( nums [ i ] , map . getOrDefault ( nums [ i ] , 0 ) + 1 ); // add the unique elements of HashMap to Minheap for ( Integer i : map . keySet ()){ heap . add ( new Element ( i , map . get ( i ))); // if size of heap becomes > k, extract the min element if ( heap . size () > k ) heap . poll (); } // Now our min heap contains top 'k' frequent elements int top [] = new int [ k ] ; int i = 0 ; // Return the top 'k' frequent elements present in the heap while ( k -- > 0 ) top [ i ++] = heap . poll (). element ; return top ; } } Time Complexity : O(n*log k) where n is the length of array Space Complexity : O(n) where n is the length of array Approach 2 : HashMap + Sorting Java class Solution { public int [] topKFrequent ( int [] nums , int k ) { int [] result = new int [ k ] ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > (); // Hashmap which stores (element, frequency) for ( int i = 0 ; i < nums . length ; i ++ ) map . put ( nums [ i ] , map . getOrDefault ( nums [ i ] , 0 ) + 1 ); // Create a list from the map List < Map . Entry < Integer , Integer >> list = new LinkedList < Map . Entry < Integer , Integer >> ( map . entrySet ()); // Sort the list using lambda expression Collections . sort ( list , ( e1 , e2 ) -> e2 . getValue (). compareTo ( e1 . getValue ())); // put elements from sorted list to the result array int i = 0 ; for ( Map . Entry < Integer , Integer > itr : list ) { result [ i ++] = itr . getKey (); if ( i >= k ) break ; } return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"347. Top K Frequent Elements"},{"location":"problems/349-intersection-of-two-arrays/","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/intersection-of-two-arrays/ Approach : Sorting + Binary Search Java C++ class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { int n1 = nums1 . length , n2 = nums2 . length , i = 0 ; Set < Integer > set = new HashSet < Integer > (); int [] baseArr , searchArr ; Arrays . sort ( nums1 ); Arrays . sort ( nums2 ); if ( n1 < n2 ){ baseArr = nums1 ; searchArr = nums2 ; } else { baseArr = nums2 ; searchArr = nums1 ; } for ( int n : baseArr ){ if ( find ( searchArr , n )) set . add ( n ); } int result [] = new int [ set . size () ] ; Iterator < Integer > it = set . iterator (); while ( it . hasNext ()) result [ i ++] = it . next (); return result ; } public boolean find ( int nums [] , int target ){ int low = 0 , high = nums . length - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ) return true ; else if ( nums [ mid ] > target ) high = mid - 1 ; else low = mid + 1 ; } return false ; } } Time Complexity : O(nlogn + mlogm + nlogm) where n & m are size of arrays nums1 and nums2 Space Complexity : O(max(n, m)) where n & m are size of arrays nums1 and nums2","title":"349. Intersection of Two Arrays"},{"location":"problems/35-search-insert-position/","tags":["Array","Binary Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-insert-position/ Approach : Modified Binary Search Java C++ class Solution { public int searchInsert ( int [] nums , int target ) { int low = 0 , high = nums . length - 1 ; while ( low <= high ){ int mid = low + ( high - low ) / 2 ; if ( nums [ mid ] == target ) return mid ; if ( nums [ mid ] < target ) low = mid + 1 ; else high = mid - 1 ; } return low ; } } Time Complexity : O(log n) where n = number of elements in array Space Complexity : O(1)","title":"35. Search Insert Position"},{"location":"problems/392-is-subsequence/","tags":["Two Pointers","String","Dynamic Programming"],"text":"Leetcode Problem Link : https://leetcode.com/problems/is-subsequence/ Approach 1 : LCS approach using Dynamic Programming - Tabulation If string s has to be subsequence of string t , then length of LCS(s, t) = length of string s Java C++ class Solution { public boolean isSubsequence ( String s , String t ) { int m = s . length (), n = t . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ){ if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } return ( m == dp [ m ][ n ] ); } } Time Complexity : O(m*n) where m & n are length of strings s and t Space Complexity : O(m*n) where m & n are length of strings s and t Approach 2 : Two Pointer approach The idea is to use two pointers, first pointing at string s and second pointing at string t . Whenever the characters match pointed by these pointers, increment pointer pointing at strings s and t both. Otherwise increment pointer pointing at string t . Java C++ class Solution { public boolean isSubsequence ( String s , String t ) { int m = s . length (), n = t . length (); int i = 0 , j = 0 ; while ( i < m && j < n ){ if ( s . charAt ( i ) == t . charAt ( j )) i ++ ; j ++ ; } return ( i == m ); } } Time Complexity : O(max(m,n)) where m & n are length of strings s and t Space Complexity : O(1)","title":"392. Is Subsequence"},{"location":"problems/40-combination-sum-ii/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/combination-sum-ii/ Approach : Backtracking Java class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { Arrays . sort ( candidates ); solve ( candidates , target , 0 , new ArrayList < Integer > ()); return result ; } public void solve ( int [] candidates , int target , int curr , List < Integer > list ){ int n = candidates . length ; if ( target == 0 ){ result . add ( new ArrayList ( list )); return ; } if ( curr >= n || target < 0 ) return ; for ( int i = curr ; i < n ; i ++ ){ if ( i > curr && candidates [ i ] == candidates [ i - 1 ] ) continue ; list . add ( candidates [ i ] ); solve ( candidates , target - candidates [ i ] , i + 1 , list ); list . remove ( new Integer ( candidates [ i ] )); } } } Time Complexity : O(2 n *k) where k = average length of combinations Space Complexity :","title":"40. Combination Sum II"},{"location":"problems/42-trapping-rain-water/","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"],"text":"Leetcode Problem Link : https://leetcode.com/problems/trapping-rain-water/ Approach : Prefix Array approach Java class Solution { public int trap ( int [] height ) { int n = height . length ; int [] left = new int [ n ] ; int [] right = new int [ n ] ; left [ 0 ] = height [ 0 ] ; right [ n - 1 ] = height [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ){ left [ i ] = Math . max ( left [ i - 1 ] , height [ i ] ); right [ n - 1 - i ] = Math . max ( right [ n - i ] , height [ n - 1 - i ] ); } int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) total += Math . min ( left [ i ] , right [ i ] ) - height [ i ] ; return total ; } } Time Complexity : O(n) where n is the number of bars Space Complexity : O(n) where n is the number of bars","title":"42. Trapping Rain Water"},{"location":"problems/46-permutations/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/permutations/ Approach : Backtracking Java class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> permute ( int [] nums ) { solve ( nums , new ArrayList < Integer > ()); return result ; } public void solve ( int nums [] , List < Integer > list ){ if ( list . size () == nums . length ) result . add ( new ArrayList < Integer > ( list )); for ( int i = 0 ; i < nums . length ; i ++ ){ if ( list . contains ( nums [ i ] )) continue ; list . add ( nums [ i ] ); solve ( nums , list ); list . remove ( Integer . valueOf ( nums [ i ] )); } } } Time Complexity : O(2 n *k) where k = average length of combinations Space Complexity :","title":"46. Permutations"},{"location":"problems/51-n-queens/","tags":["Array","Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/n-queens/ Approach : Recursion + Backtracking Java C++ class Solution { List < List < String >> result = new ArrayList < List < String >> (); public List < List < String >> solveNQueens ( int n ) { char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < board . length ; i ++ ) Arrays . fill ( board [ i ] , '.' ); place ( board , 0 ); return result ; } public void place ( char board [][] , int row ){ if ( row == board . length ){ List < String > list = new ArrayList < String > (); for ( int i = 0 ; i < board . length ; i ++ ) list . add ( String . valueOf ( board [ i ] )); result . add ( list ); return ; } for ( int col = 0 ; col < board . length ; col ++ ){ if ( isSafe ( board , row , col )){ board [ row ][ col ] = 'Q' ; place ( board , row + 1 ); board [ row ][ col ] = '.' ; } } } public boolean isSafe ( char [][] board , int row , int col ){ if ( ! columnSafe ( board , row , col ) || ! diagonalSafe ( board , row , col )) return false ; return true ; } public boolean columnSafe ( char [][] board , int row , int col ){ for ( int i = 0 ; i < board . length ; i ++ ){ if ( board [ i ][ col ] == 'Q' ) return false ; } return true ; } public boolean diagonalSafe ( char [][] board , int row , int col ){ // Primary diagonal for ( int i = row - 1 , j = col + 1 ; i >= 0 && j < board . length ; i -- , j ++ ) if ( board [ i ][ j ] == 'Q' ) return false ; // Secondary diagonal for ( int i = row - 1 , j = col - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) if ( board [ i ][ j ] == 'Q' ) return false ; return true ; } } Time Complexity : O(N!) where N is the number of queens Space Complexity : O(N) where N is the number of queens","title":"51. N-Queens"},{"location":"problems/513-find-bottom-left-tree-value/","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-bottom-left-tree-value/ Approach 1 : DFS Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int maxHeight = - 1 ; int bottomLeft = - 1 ; public int findBottomLeftValue ( TreeNode root ) { solve ( root , 0 ); return bottomLeft ; } public void solve ( TreeNode root , int currHeight ){ if ( maxHeight < currHeight ){ maxHeight = currHeight ; bottomLeft = root . val ; } if ( root . left != null ) solve ( root . left , currHeight + 1 ); if ( root . right != null ) solve ( root . right , currHeight + 1 ); } } Time Complexity : O(n) where n = number of nodes in the tree Space Complexity : O(n) where n = number of nodes in the tree","title":"513. Find Bottom Left Tree Value"},{"location":"problems/516-longest-palindromic-subsequence/","tags":["String","Dynamic Programming"],"text":"Leetcode Problem Link : https://leetcode.com/problems/longest-palindromic-subsequence/ Approach : Dynamic Programming - Tabulation Java C++ class Solution { public int longestPalindromeSubseq ( String s ) { String t = new StringBuilder ( s ). reverse (). toString (); int n = s . length (); int [][] dp = new int [ n + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ){ if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); } } return dp [ n ][ n ] ; } } Time Complexity : O(n 2 ) where n = length of string s Space Complexity : O(n 2 ) where n = length of string s","title":"516. Longest Palindromic Subsequence"},{"location":"problems/537-complex-number-multiplication/","tags":["Math","String","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/complex-number-multiplication/ Approach : Formula Simulation Java C++ class Solution { public String complexNumberMultiply ( String num1 , String num2 ) { // e.g. nums1 = 1+1i, nums2 = 1+-1i // n1 = [\"1\", \"1i\"], n2 = [\"1\", \"-1i\"] String [] n1 = num1 . split ( \"\\\\+\" ); String [] n2 = num2 . split ( \"\\\\+\" ); // r1 = 1, r2 = 1 // c1 = 1, c2 = -1 // for c1, c2 ==> take 2nd part of splitted string from 0th index to second last index // this will exclude 'i' from the splitted string to get actual complex part int r1 = Integer . parseInt ( n1 [ 0 ] ); int r2 = Integer . parseInt ( n2 [ 0 ] ); int c1 = Integer . parseInt ( n1 [ 1 ] . substring ( 0 , n1 [ 1 ] . length () - 1 )); int c2 = Integer . parseInt ( n2 [ 1 ] . substring ( 0 , n2 [ 1 ] . length () - 1 )); int real = r1 * r2 + ( c1 * c2 *- 1 ); int complex = r1 * c2 + r2 * c1 ; String result = Integer . toString ( real ) + \"+\" + Integer . toString ( complex ) + \"i\" ; return result ; } } Time Complexity : O(1) Space Complexity : O(1)","title":"537. Complex Number Multiplication"},{"location":"problems/56-merge-intervals/","tags":["Array","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/merge-intervals/ Approach : Sorting Java C++ class Solution { public int [][] merge ( int [][] intervals ) { Arrays . sort ( intervals , ( a , b ) -> Integer . compare ( a [ 0 ] , b [ 0 ] )); List < int []> list = new ArrayList < int []> (); int idx = 0 ; list . add ( intervals [ 0 ] ); for ( int i = 1 ; i < intervals . length ; i ++ ){ int [] arr = list . get ( idx ); if ( arr [ 1 ] >= intervals [ i ][ 0 ] ){ arr [ 1 ] = Math . max ( arr [ 1 ] , intervals [ i ][ 1 ] ); list . set ( idx , arr ); } else { list . add ( intervals [ i ] ); idx ++ ; } } int n = list . size (); int [][] result = new int [ n ][ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) result [ i ] = list . get ( i ); return result ; } } Time Complexity : O(nlogn + n + n) where n = given number of intervals Space Complexity : O(n) where n = given number of intervals","title":"56. Merge Intervals"},{"location":"problems/594-longest-harmonious-subsequence/","tags":["Array","Hash Table","Sorting"],"text":"Leetcode Problem Link : https://leetcode.com/problems/longest-harmonious-subsequence/ Approach : HashMap Java C++ class Solution { public int findLHS ( int [] nums ) { int lhs = 0 ; Map < Integer , Integer > map = new HashMap < Integer , Integer > (); for ( int i = 0 ; i < nums . length ; i ++ ) map . put ( nums [ i ] , map . getOrDefault ( nums [ i ] , 0 ) + 1 ); for ( Integer key : map . keySet ()){ if ( map . containsKey ( key + 1 )) lhs = Math . max ( lhs , map . get ( key ) + map . get ( key + 1 )); } return lhs ; } } Time Complexity : O(n) where n = length of array nums Space Complexity : O(n) where n = length of array nums","title":"594. Longest Harmonious Subsequence"},{"location":"problems/609-find-duplicate-file-in-system/","tags":["Array","Hash Table","String"],"text":"Leetcode Problem Link : https://leetcode.com/problems/find-duplicate-file-in-system/ Approach : HashMap Java C++ class Solution { public List < List < String >> findDuplicate ( String [] paths ) { Map < String , List < String >> map = new HashMap < String , List < String >> (); for ( int i = 0 ; i < paths . length ; i ++ ){ String [] arr = paths [ i ] . split ( \" \" ); String dir = arr [ 0 ] ; for ( int j = 1 ; j < arr . length ; j ++ ){ int idx = arr [ j ] . indexOf ( \"(\" ); String filename = arr [ j ] . substring ( 0 , idx ); String content = arr [ j ] . substring ( idx + 1 , arr [ j ] . indexOf ( \")\" )); List < String > list = map . getOrDefault ( content , new ArrayList < String > ()); String path = dir + \"/\" + filename ; list . add ( path ); map . put ( content , list ); } } List < List < String >> result = new ArrayList < List < String >> (); for ( List < String > path : map . values ()){ if ( path . size () > 1 ) result . add ( path ); } return result ; } } Time Complexity : O(p*k*m*l*l) where p = paths.length, k = paths[i].length, m = #files in directory, l = len(filename+content) Space Complexity :","title":"609. Find Duplicate File in System"},{"location":"problems/62-unique-paths/","tags":["Math","Dynamic Programming","Combinatorics"],"text":"Leetcode Problem Link : https://leetcode.com/problems/unique-paths/ Approach 1 : Brute Force Try all possible cases to reach to the final position. Java class Solution { public int uniquePaths ( int m , int n ) { // base case if ( m == 1 || n == 1 ) return 1 ; // move down int downMove = uniquePaths ( m - 1 , n ); // move right int rightMove = uniquePaths ( m , n - 1 ); return downMove + rightMove ; } } Time Complexity : O(2 mn ) Space Complexity : O(max(m,n)) Approach 2 : Memoization Here, we store the value for number of unique paths calculated for cell(i, j), so that if we encounter same subproblem in further recursive calls, we can directly use the calculated value instead of re-calculating for that cell. Java class Solution { private Map < String , Integer > map = new HashMap < String , Integer > (); public int uniquePaths ( int m , int n ) { // base case if ( m == 1 || n == 1 ) return 1 ; // check if we have already calculated unique paths for cell(m, n) String cell = new String ( m + \",\" + n ); // if yes, then get its value from our memoization table if ( map . containsKey ( cell )) return map . get ( cell ); // else, explore the down move int downMove = uniquePaths ( m - 1 , n ); // explore the right move int rightMove = uniquePaths ( m , n - 1 ); // put the value obtained for unique paths from cell(m, n) map . put ( cell , downMove + rightMove ); return downMove + rightMove ; } } Time Complexity : O(m*n) Space Complexity : O(m*n) Approach 3 : Dynamic Programming Using DP, we find the number of unique paths from a given cell is equal to as the sum of the values of its previous possible states. dp[i,j] = dp[i-1,j] + dp[i,j-1] gives us the idea. To reach the position (i, j) , the path should either be coming from (i-1, j) or (i, j-1) . Now, we can use either top-down or bottom-up approach to calculate the number of unique paths. Approach 3.1 : Top-Down Dynamic Programming We start from top-left corner i.e. (0, 0) and finding paths in forward approach by using the formula dp[i][j] = dp[i-1][j] + dp[i][j-1] . The base case here is when i == 0 || j == 0 , dp[i][j] = 1 . Here, dp[i][j] represents the number of paths from cell (0, 0) to cell (i, j). Java class Solution { public int uniquePaths ( int m , int n ) { int [][] dp = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( i == 0 || j == 0 ) dp [ i ][ j ] = 1 ; else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ] ; } } return dp [ m - 1 ][ n - 1 ] ; } } Time Complexity : O(m*n) Space Complexity : O(m*n) Approach 3.2: Bottom-Up Dynamic Programming We will start from the bottom-right corner (m, n) and find finding paths using backward approach using the formula dp[i][j] = dp[i+1][j] + dp[i][j+1] , where m = no. of rows and n = no. of columns. The base case here is when i == m-1 || j == n-1 , dp[i][j] = 1 . Here, dp[i][j] represents the number of paths from cell (m, n) to cell (i, j). Java class Solution { public int uniquePaths ( int m , int n ) { int [][] dp = new int [ m ][ n ] ; for ( int i = m - 1 ; i >= 0 ; i -- ){ for ( int j = n - 1 ; j >= 0 ; j -- ){ if ( i == m - 1 || j == n - 1 ) dp [ i ][ j ] = 1 ; else dp [ i ][ j ] = dp [ i ][ j + 1 ] + dp [ i + 1 ][ j ] ; } } return dp [ 0 ][ 0 ] ; } } Time Complexity : O(m*n) Space Complexity : O(m*n)","title":"62. Unique Paths"},{"location":"problems/63-unique-paths-ii/","tags":["Array","Dynamic Programming","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/unique-paths-ii/ Approach : Dynamic Programming - Tabulation Java class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { int m = obstacleGrid . length ; int n = obstacleGrid [ 0 ] . length ; if ( obstacleGrid [ 0 ][ 0 ] == 1 ) return 0 ; int [][] dp = new int [ m ][ n ] ; dp [ 0 ][ 0 ] = 1 ; for ( int c = 1 ; c < n ; c ++ ){ if ( obstacleGrid [ 0 ][ c ] == 1 ) dp [ 0 ][ c ] = 0 ; else dp [ 0 ][ c ] = Math . min ( dp [ 0 ][ c - 1 ] , 1 ); } for ( int r = 1 ; r < m ; r ++ ){ if ( obstacleGrid [ r ][ 0 ] == 1 ) dp [ r ][ 0 ] = 0 ; else dp [ r ][ 0 ] = Math . min ( dp [ r - 1 ][ 0 ] , 1 ); } for ( int i = 1 ; i < m ; i ++ ){ for ( int j = 1 ; j < n ; j ++ ){ if ( obstacleGrid [ i ][ j ] == 1 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ] ; } } return dp [ m - 1 ][ n - 1 ] ; } } Time Complexity : O(m*n) where m & n are dimensions of matrix Space Complexity : O(m*n) where m & n are dimensions of matrix","title":"63. Unique Paths II"},{"location":"problems/682-baseball-game/","tags":["Array","Stack","Simulation"],"text":"Leetcode Problem Link : https://leetcode.com/problems/baseball-game/ Approach : Simulation Java C++ class Solution { public int calPoints ( String [] ops ) { List < Integer > list = new ArrayList < Integer > (); int size = 0 , sum = 0 ; for ( String op : ops ){ if ( op . equals ( \"C\" )) list . remove ( -- size ); else if ( op . equals ( \"D\" )){ list . add ( list . get ( size - 1 ) * 2 ); size ++ ; } else if ( op . equals ( \"+\" )){ list . add ( list . get ( size - 1 ) + list . get ( size - 2 )); size ++ ; } else { list . add ( new Integer ( op )); size ++ ; } } for ( Integer i : list ) sum += i ; return sum ; } } Time Complexity : O(n) where n = number of operations Space Complexity : O(n) where n = number of operations","title":"682. Baseball Game"},{"location":"problems/692-top-k-frequent-words/","tags":["Array","Hash Table","Divide and Conquer","Sorting","Heap (Priority Queue)","Bucket Sort","Counting","Quick Select"],"text":"Leetcode Problem Link : https://leetcode.com/problems/top-k-frequent-elements/ Approach 1 : Using Heap (PriorityQueue) Java class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > result = new ArrayList < String > (); HashMap < String , Integer > map = new HashMap < String , Integer > (); // MaxHeap to store the strings based on their frequency Queue < String > heap = new PriorityQueue < String > ( ( e1 , e2 ) -> map . get ( e1 ) == map . get ( e2 ) ? e1 . compareTo ( e2 ) : map . get ( e2 ) - map . get ( e1 )); // Hashmap which stores (element, frequency) for ( String str : words ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); // Add the unique elements of HashMap to Maxheap for ( String str : map . keySet ()) heap . add ( str ); // Add the top 'k' frequent strings from heap into the result while ( k -- > 0 ) result . add ( heap . poll ()); return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array Approach 2 : HashMap + Sorting Java class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > result = new ArrayList < String > (); HashMap < String , Integer > map = new HashMap < String , Integer > (); // Hashmap which stores (element, frequency) for ( String str : words ) map . put ( str , map . getOrDefault ( str , 0 ) + 1 ); // Create a list from the map List < Map . Entry < String , Integer >> list = new LinkedList < Map . Entry < String , Integer >> ( map . entrySet ()); // Sort the list using lambda expression Collections . sort ( list , ( e1 , e2 ) -> e1 . getValue () == e2 . getValue () ? e1 . getKey (). compareTo ( e2 . getKey ()) : e2 . getValue () - e1 . getValue ()); // put elements from sorted list to the result array int i = 0 ; for ( Map . Entry < String , Integer > itr : list ) { result . add ( itr . getKey ()); if ( ++ i >= k ) break ; } return result ; } } Time Complexity : O(n*log n) where n is the length of array Space Complexity : O(n) where n is the length of array","title":"692. Top K Frequent Words"},{"location":"problems/695-max-area-of-island/","tags":["Array","Depth-First Search","Breadth-First Search","Union Find","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/max-area-of-island/ Approach : DFS Java C++ class Solution { boolean [][] visited ; public int maxAreaOfIsland ( int [][] grid ) { int m = grid . length , n = grid [ 0 ] . length ; visited = new boolean [ m ][ n ] ; int largestArea = 0 ; for ( int i = 0 ; i < m ; i ++ ){ for ( int j = 0 ; j < n ; j ++ ){ if ( grid [ i ][ j ] == 1 && ! visited [ i ][ j ] ) largestArea = Math . max ( largestArea , explore ( grid , m , n , i , j )); } } return largestArea ; } public int explore ( int [][] grid , int m , int n , int row , int col ){ // base case 1: if we go out of bounds of the matrix if ( row < 0 || col < 0 || row >= m || col >= n ) return 0 ; // base case 2: if we are not currently at island (grid[i][j] == 0) // or we have already visited this island if ( grid [ row ][ col ] == 0 || visited [ row ][ col ] ) return 0 ; // visit the current island visited [ row ][ col ] = true ; // recursively visit islands to left, right, above below int left = explore ( grid , m , n , row , col - 1 ); int right = explore ( grid , m , n , row , col + 1 ); int above = explore ( grid , m , n , row - 1 , col ); int below = explore ( grid , m , n , row + 1 , col ); // maximum area would be 1 + sum of area of its neighbouring islands // we add 1 because we should also add current island's area int maxArea = 1 + left + right + above + below ; return maxArea ; } } Time Complexity : O(m*n) where m = numeber of rows, n = number of columns Space Complexity : O(m*n) where m = numeber of rows, n = number of columns","title":"695. Max Area of Island"},{"location":"problems/700-search-in-a-binary-search-tree/","tags":["Tree","Binary Search Tree","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Approach : Recursion Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode searchBST ( TreeNode root , int val ) { // if root is null, then return null if ( root == null ) return null ; // if root's val matches val, then return root if ( root . val == val ) return root ; // if root's val is greater than val, // so the target node will be in left subtree of root if ( root . val > val ) return searchBST ( root . left , val ); // otherwise, it means root's val is less than val, // so the target node will be in left subtree of root else return searchBST ( root . right , val ); } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * searchBST ( TreeNode * root , int val ) { // if root is null, then return null if ( ! root ) return root ; // if root's val matches val, then return root if ( root -> val == val ) return root ; // if root's val is greater than val, // so the target node will be in left subtree of root if ( root -> val > val ) return searchBST ( root -> left , val ); // otherwise, it means root's val is less than val, // so the target node will be in left subtree of root else return searchBST ( root -> right , val ); } }; Time Complexity : O(n) where n is the number of nodes in the tree Space Complexity : O(n)","title":"700. Search in a Binary Search Tree"},{"location":"problems/73-set-matrix-zeroes/","tags":["Array","Hash Table","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/set-matrix-zeroes/ Java class Solution { public void setZeroes ( int [][] matrix ) { Set < Integer > rows = new HashSet < Integer > (); Set < Integer > cols = new HashSet < Integer > (); for ( int i = 0 ; i < matrix . length ; i ++ ){ for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ){ if ( matrix [ i ][ j ] == 0 ){ rows . add ( i ); cols . add ( j ); } } } for ( int i = 0 ; i < matrix . length ; i ++ ){ for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ){ if ( rows . contains ( i ) || cols . contains ( j )){ matrix [ i ][ j ] = 0 ; } } } } } Time Complexity : O(m*n) where ( m,n ) is the dimension of matrix Space Complexity : O(m*n) where ( m,n ) is the dimension of matrix","title":"73. Set Matrix Zeroes"},{"location":"problems/74-search-a-2d-matrix/","tags":["Array","Binary Search","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/search-a-2d-matrix/ Approach : Binary Search Java C++ class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { int m = matrix . length , n = matrix [ 0 ] . length ; int top = 0 , bottom = m - 1 ; int left = 0 , right = n - 1 ; int row = 0 ; while ( top <= bottom ){ int mid = top + ( bottom - top ) / 2 ; if ( matrix [ mid ][ left ] <= target && matrix [ mid ][ right ] >= target ){ row = mid ; break ; } if ( matrix [ mid ][ left ] > target ) bottom = mid - 1 ; else if ( matrix [ mid ][ right ] < target ) top = mid + 1 ; } while ( left <= right ){ int mid = left + ( right - left ) / 2 ; if ( matrix [ row ][ mid ] == target ) return true ; if ( matrix [ row ][ mid ] < target ) left = mid + 1 ; else right = mid - 1 ; } return false ; } } Time Complexity : O(log m*n) where m = numeber of rows, n = number of columns Space Complexity : O(1)","title":"74. Search a 2D Matrix"},{"location":"problems/75-sort-colors/","tags":["Array","Dynamic Programming","Breadth-First Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/sort-colors/ Approach 1 : Counting Sort approach Java C++ class Solution { public void sortColors ( int [] nums ) { int [] arr = new int [ 3 ] ; int i = 0 ; for ( int color : nums ) arr [ color ]++ ; for ( int color = 0 ; color < 3 ; color ++ ){ while ( arr [ color ]-- > 0 ) nums [ i ++] = color ; } } } Time Complexity : O(n) where n = size of array Space Complexity : O(1) Approach 2 : Dutch National Flag Sort(DNF Sort) approach The algorithm is as follows: Initialise low = 0, mid = 0 and high = n - 1 [0,low] indicates region of 0's in array [low, mid-1] indicates region of 1's in array [mid, high-1] indicates unknown region in array [high, n-1] indicates region of 2's in array Now, perform following steps while mid <= high & check arr[mid] value: a. If 0 , then swap arr[low] and arr[mid] and do low++ , mid++ b. If 1 , then mid++ c. If 2 , then swap arr[mid] and arr[high] and do high-- Java class Solution { public void sortColors ( int [] nums ) { int n = nums . length ; int low = 0 , mid = 0 , high = n - 1 ; while ( mid <= high ){ if ( nums [ mid ] == 0 ){ int temp = nums [ low ] ; nums [ low ] = nums [ mid ] ; nums [ mid ] = temp ; low ++ ; mid ++ ; } else if ( nums [ mid ] == 1 ){ mid ++ ; } else { int temp = nums [ mid ] ; nums [ mid ] = nums [ high ] ; nums [ high ] = temp ; high -- ; } } } } Time Complexity : O(n) where n = size of array Space Complexity : O(1)","title":"75. Sort Colors"},{"location":"problems/77-combinations/","tags":["Backtracking"],"text":"Leetcode Problem Link : https://leetcode.com/problems/combinations/ Approach : Backtracking Java C++ class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> combine ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ){ List < Integer > list = new ArrayList < Integer > (); list . add ( i ); solve ( i , n , k - 1 , list ); } return result ; } public void solve ( int curr , int n , int k , List < Integer > list ){ if ( k < 0 ) return ; if ( k == 0 ){ result . add ( new ArrayList < Integer > ( list )); return ; } for ( int i = curr + 1 ; i <= n ; i ++ ){ list . add ( i ); solve ( i , n , k - 1 , list ); list . remove ( new Integer ( i )); } } } Time Complexity : Space Complexity :","title":"77. Combinations"},{"location":"problems/785-is-graph-bipartite/","tags":["Depth-First Search","Breadth-First Search","Union Find","Graph"],"text":"Leetcode Problem Link : https://leetcode.com/problems/is-graph-bipartite/ Approach 1 : BFS Java C++ class Solution { public boolean isBipartite ( int [][] graph ) { int V = graph . length ; int [] colors = new int [ V ] ; Arrays . fill ( colors , - 1 ); for ( int v = 0 ; v < V ; ++ v ){ if ( colors [ v ] == - 1 && ! isValidColoring ( graph , colors , v )) return false ; } return true ; } public boolean isValidColoring ( int [][] graph , int [] colors , int src ){ Queue < Integer > queue = new LinkedList < Integer > (); queue . add ( src ); colors [ src ] = 1 ; while ( ! queue . isEmpty ()){ int u = queue . poll (); for ( int i = 0 ; i < graph [ u ] . length ; i ++ ){ int v = graph [ u ][ i ] ; if ( colors [ v ] == - 1 ){ colors [ v ] = 1 - colors [ u ] ; queue . add ( v ); } else if ( colors [ v ] == colors [ u ] ) return false ; } } return true ; } } Time Complexity : O(n + e) where n = number of nodes & edges in the graph respectively Space Complexity : O(n) where n = number of nodes in the graph","title":"785. Is Graph Bipartite?"},{"location":"problems/797-all-paths-from-source-to-target/","tags":["Backtracking","Depth-First Search","Breadth-First Search","Graph"],"text":"Leetcode Problem Link : https://leetcode.com/problems/all-paths-from-source-to-target/ Approach : DFS + Backtracking Java C++ class Solution { List < List < Integer >> result = new ArrayList < List < Integer >> (); public List < List < Integer >> allPathsSourceTarget ( int [][] graph ) { findPaths ( 0 , graph , new ArrayList < Integer > ()); return result ; } public void findPaths ( int node , int [][] graph , List < Integer > list ){ // if node vertex is the target vertex, then add the list to result // since we have found one of the directed path to target // the list maintains the nodes we which are used to reach vertex 'node' if ( node == graph . length - 1 ){ list . add ( node ); result . add ( new ArrayList < Integer > ( list )); list . remove ( new Integer ( node )); return ; } // add the current node to the list list . add ( node ); // recursively find path for through adjacent vertices of current node for ( int i = 0 ; i < graph [ node ] . length ; i ++ ) findPaths ( graph [ node ][ i ] , graph , list ); // remove the node from the path list . remove ( new Integer ( node )); return ; } } Time Complexity : O(E) where E is the number of edges in DAG Space Complexity : O(V) where V is the number of vertices in DAG","title":"797. All Paths From Source to Target"},{"location":"problems/89-gray-code/","tags":["Recursion","Linked List"],"text":"Leetcode Problem Link : https://leetcode.com/problems/gray-code/ Approach 1 : Simple Recursive Approach Java class Solution { public List < Integer > grayCode ( int n ) { List < Integer > result = new ArrayList < Integer > (); List < String > codes = generate ( n ); int size = codes . size (); // Convert the gray codes from binary strings to decimal values for ( int i = 0 ; i < size ; i ++ ) result . add ( Integer . parseInt ( codes . get ( i ), 2 )); return result ; } public List < String > generate ( int n ){ // Base Case if ( n == 1 ) return Arrays . asList ( new String [] { \"0\" , \"1\" }); // Recursively get (n-1)bit gray codes List < String > codes = generate ( n - 1 ); List < String > answer = new ArrayList < String > (); int size = codes . size (); // Append \"0\" to (n-1)bit gray codes from first to last for ( int i = 0 ; i < size ; i ++ ) answer . add ( new String ( \"0\" + codes . get ( i ))); // Append \"1\" to (n-1)bit gray codes from last to first for ( int i = size - 1 ; i >= 0 ; i -- ) answer . add ( new String ( \"1\" + codes . get ( i ))); // return the n-bit gray codes (binary strings) return answer ; } } Time Complexity : O() Space Complexity : O(2 n ) where n is number of gray code bits","title":"89. Gray Code"},{"location":"problems/896-middle-of-the-linked-list/","tags":["Linked List","Two pointers"],"text":"Leetcode Problem Link : https://leetcode.com/problems/middle-of-the-linked-list/ Approach 1 : Two pointers Approach Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head , fast = head ; while ( fast != null && fast . next != null ){ fast = fast . next . next ; slow = slow . next ; } return slow ; } } Time Complexity : O(n) where n is the number of nodes in linked list Space Complexity : O(1)","title":"876. Middle of the Linked List"},{"location":"problems/897-increasing-order-search-tree/","tags":["Stack","Tree","Depth-First Search","Binary Search Tree","Binary Tree"],"text":"Leetcode Problem Link : https://leetcode.com/problems/increasing-order-search-tree/ Approach : Recursion Java C++ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { TreeNode head = null ; public TreeNode increasingBST ( TreeNode root ) { inorder ( root ); return head ; } public void inorder ( TreeNode root ){ if ( root == null ) return ; inorder ( root . left ); if ( head == null ){ head = new TreeNode ( root . val ); head . left = null ; head . right = null ; } else { TreeNode ptr = head ; while ( ptr . right != null ) ptr = ptr . right ; TreeNode node = new TreeNode ( root . val ); node . left = null ; node . right = null ; ptr . right = node ; } inorder ( root . right ); } } Time Complexity : Space Complexity :","title":"897. Increasing Order Search Tree"},{"location":"problems/931-minimum-falling-path-sum/","tags":["Array","Dynamic Programming","Matrix"],"text":"Leetcode Problem Link : https://leetcode.com/problems/minimum-falling-path-sum/ Approach 1 : Brute Force (Time Limit Exceeded) Java C++ class Solution { public int minFallingPathSum ( int [][] matrix ) { int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < matrix . length ; i ++ ) min = Math . min ( min , solve ( matrix , 0 , i , 0 )); return min ; } public int solve ( int [][] matrix , int r , int c , int sum ){ int n = matrix . length ; if ( r < 0 || r >= n ) return sum ; if ( c < 0 || c >= n ){ if ( r != n ) return Integer . MAX_VALUE ; return sum ; } sum += matrix [ r ][ c ] ; int below = solve ( matrix , r + 1 , c , sum ); int diagLeft = solve ( matrix , r + 1 , c - 1 , sum ); int diagRight = solve ( matrix , r + 1 , c + 1 , sum ); return Math . min ( below , Math . min ( diagLeft , diagRight )); } } Time Complexity : Space Complexity : Approach 2 : Dynamic Programming - Tabulation Java C++ class Solution { public int minFallingPathSum ( int [][] matrix ) { int n = matrix . length ; int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ n - 1 ][ i ] = matrix [ n - 1 ][ i ] ; for ( int i = n - 2 ; i >= 0 ; i -- ){ for ( int j = 0 ; j < n ; j ++ ){ if ( j == 0 ) dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i + 1 ][ j + 1 ] ); else if ( j == n - 1 ) dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i + 1 ][ j - 1 ] ); else dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , Math . min ( dp [ i + 1 ][ j - 1 ] , dp [ i + 1 ][ j + 1 ] )); dp [ i ][ j ] += matrix [ i ][ j ] ; } } int min = dp [ 0 ][ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) min = Math . min ( min , dp [ 0 ][ i ] ); return min ; } } Time Complexity : O(n 2 ) where size of matrix is n * n Space Complexity : O(n 2 ) where size of matrix is n * n","title":"931. Minimum Falling Path Sum"},{"location":"problems/967-numbers-with-same-consecutive-differences/","tags":["Backtracking","Breadth-First Search"],"text":"Leetcode Problem Link : https://leetcode.com/problems/numbers-with-same-consecutive-differences/ Approach : DFS + Backtracking Java C++ class Solution { public int [] numsSameConsecDiff ( int n , int k ) { List < Integer > answer = new ArrayList < Integer > (); for ( int i = 1 ; i <= 9 ; i ++ ){ helper ( i , n - 1 , k , answer , 0 ); } int size = answer . size (); int [] result = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) result [ i ] = answer . get ( i ); return result ; } public void helper ( int d , int n , int k , List < Integer > answer , int number ){ number = number * 10 + d ; if ( n == 0 ){ answer . add ( number ); return ; } int c1 = d + k ; int c2 = d - k ; if ( c1 <= 9 ) helper ( c1 , n - 1 , k , answer , number ); if ( c1 != c2 && c2 >= 0 ) helper ( c2 , n - 1 , k , answer , number ); return ; } } Time Complexity : O(2 n ) where n = number of digits in each combination Space Complexity : O(2 n ) where n = number of digits in each combination","title":"967. Numbers With Same Consecutive Differences"},{"location":"tags/","text":"Tags \u00b6 Following is a list of tags: Array \u00b6 1. Two Sum 11. Container With Most Water 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 1980. Find Unique Binary String 200. Number of Islands 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 216. Combination Sum III 268. Missing Number 322. Coin Change 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 40. Combination Sum II 42. Trapping Rain Water 46. Permutations 51. N-Queens 56. Merge Intervals 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 63. Unique Paths II 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 75. Sort Colors 931. Minimum Falling Path Sum Backtracking \u00b6 1980. Find Unique Binary String 216. Combination Sum III 40. Combination Sum II 46. Permutations 51. N-Queens 77. Combinations 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences Binary Search \u00b6 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix Binary Search Tree \u00b6 230. Kth Smallest Element in a BST 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Binary Tree \u00b6 100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Bit Manipulation \u00b6 268. Missing Number Breadth-First Search \u00b6 100. Same Tree 200. Number of Islands 322. Coin Change 513. Find Bottom Left Tree Value 695. Max Area of Island 75. Sort Colors 785. Is Graph Bipartite? 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences Bucket Sort \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Combinatorics \u00b6 62. Unique Paths Counting \u00b6 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 347. Top K Frequent Elements 692. Top K Frequent Words Depth-First Search \u00b6 100. Same Tree 200. Number of Islands 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 695. Max Area of Island 785. Is Graph Bipartite? 797. All Paths From Source to Target 897. Increasing Order Search Tree Divide and Conquer \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Dynamic Programming \u00b6 1092. Shortest Common Supersequence 1143. Longest Common Subsequence 322. Coin Change 392. Is Subsequence 42. Trapping Rain Water 516. Longest Palindromic Subsequence 62. Unique Paths 63. Unique Paths II 75. Sort Colors 931. Minimum Falling Path Sum Graph \u00b6 785. Is Graph Bipartite? 797. All Paths From Source to Target Greedy \u00b6 11. Container With Most Water 2224. Minimum Number of Operations to Convert Time Hash Table \u00b6 1. Two Sum 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 692. Top K Frequent Words 73. Set Matrix Zeroes Heap (Priority Queue) \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Linked List \u00b6 1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List Math \u00b6 268. Missing Number 537. Complex Number Multiplication 62. Unique Paths Matrix \u00b6 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 63. Unique Paths II 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 931. Minimum Falling Path Sum Monotonic Stack \u00b6 42. Trapping Rain Water Quick Select \u00b6 347. Top K Frequent Elements 692. Top K Frequent Words Recursion \u00b6 203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code Simulation \u00b6 1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game Sorting \u00b6 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 56. Merge Intervals 594. Longest Harmonious Subsequence 692. Top K Frequent Words Stack \u00b6 2130. Maximum Twin Sum of a Linked List 42. Trapping Rain Water 682. Baseball Game 897. Increasing Order Search Tree String \u00b6 1092. Shortest Common Supersequence 1143. Longest Common Subsequence 1880. Check if Word Equals Summation of Two Words 1980. Find Unique Binary String 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 2224. Minimum Number of Operations to Convert Time 344. Reverse String 392. Is Subsequence 516. Longest Palindromic Subsequence 537. Complex Number Multiplication 609. Find Duplicate File in System Tree \u00b6 100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree Two Pointers \u00b6 11. Container With Most Water 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays 392. Is Subsequence 42. Trapping Rain Water Two pointers \u00b6 2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List Union Find \u00b6 200. Number of Islands 695. Max Area of Island 785. Is Graph Bipartite?","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of tags:","title":"Tags"},{"location":"tags/#array","text":"1. Two Sum 11. Container With Most Water 1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 1980. Find Unique Binary String 200. Number of Islands 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 216. Combination Sum III 268. Missing Number 322. Coin Change 34. Find First and Last Position of Element in Sorted Array 347. Top K Frequent Elements 349. Intersection of Two Arrays 35. Search Insert Position 40. Combination Sum II 42. Trapping Rain Water 46. Permutations 51. N-Queens 56. Merge Intervals 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 63. Unique Paths II 682. Baseball Game 692. Top K Frequent Words 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 75. Sort Colors 931. Minimum Falling Path Sum","title":"Array"},{"location":"tags/#backtracking","text":"1980. Find Unique Binary String 216. Combination Sum III 40. Combination Sum II 46. Permutations 51. N-Queens 77. Combinations 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences","title":"Backtracking"},{"location":"tags/#binary-search","text":"1351. Count Negative Numbers in a Sorted Matrix 153. Find Minimum in Rotated Sorted Array 1539. Kth Missing Positive Number 34. Find First and Last Position of Element in Sorted Array 349. Intersection of Two Arrays 35. Search Insert Position 74. Search a 2D Matrix","title":"Binary Search"},{"location":"tags/#binary-search-tree","text":"230. Kth Smallest Element in a BST 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Binary Search Tree"},{"location":"tags/#binary-tree","text":"100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Binary Tree"},{"location":"tags/#bit-manipulation","text":"268. Missing Number","title":"Bit Manipulation"},{"location":"tags/#breadth-first-search","text":"100. Same Tree 200. Number of Islands 322. Coin Change 513. Find Bottom Left Tree Value 695. Max Area of Island 75. Sort Colors 785. Is Graph Bipartite? 797. All Paths From Source to Target 967. Numbers With Same Consecutive Differences","title":"Breadth-First Search"},{"location":"tags/#bucket-sort","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Bucket Sort"},{"location":"tags/#combinatorics","text":"62. Unique Paths","title":"Combinatorics"},{"location":"tags/#counting","text":"2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 347. Top K Frequent Elements 692. Top K Frequent Words","title":"Counting"},{"location":"tags/#depth-first-search","text":"100. Same Tree 200. Number of Islands 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 695. Max Area of Island 785. Is Graph Bipartite? 797. All Paths From Source to Target 897. Increasing Order Search Tree","title":"Depth-First Search"},{"location":"tags/#divide-and-conquer","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Divide and Conquer"},{"location":"tags/#dynamic-programming","text":"1092. Shortest Common Supersequence 1143. Longest Common Subsequence 322. Coin Change 392. Is Subsequence 42. Trapping Rain Water 516. Longest Palindromic Subsequence 62. Unique Paths 63. Unique Paths II 75. Sort Colors 931. Minimum Falling Path Sum","title":"Dynamic Programming"},{"location":"tags/#graph","text":"785. Is Graph Bipartite? 797. All Paths From Source to Target","title":"Graph"},{"location":"tags/#greedy","text":"11. Container With Most Water 2224. Minimum Number of Operations to Convert Time","title":"Greedy"},{"location":"tags/#hash-table","text":"1. Two Sum 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 594. Longest Harmonious Subsequence 609. Find Duplicate File in System 692. Top K Frequent Words 73. Set Matrix Zeroes","title":"Hash Table"},{"location":"tags/#heap-priority-queue","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Heap (Priority Queue)"},{"location":"tags/#linked-list","text":"1721. Swapping Nodes in a Linked List 203. Remove Linked List Elements 206. Reverse Linked List 2095. Delete the Middle Node of a Linked List 21. Merge Two Sorted Lists 2130. Maximum Twin Sum of a Linked List 89. Gray Code 876. Middle of the Linked List","title":"Linked List"},{"location":"tags/#math","text":"268. Missing Number 537. Complex Number Multiplication 62. Unique Paths","title":"Math"},{"location":"tags/#matrix","text":"1222. Queens That Can Attack the King 1351. Count Negative Numbers in a Sorted Matrix 200. Number of Islands 63. Unique Paths II 695. Max Area of Island 73. Set Matrix Zeroes 74. Search a 2D Matrix 931. Minimum Falling Path Sum","title":"Matrix"},{"location":"tags/#monotonic-stack","text":"42. Trapping Rain Water","title":"Monotonic Stack"},{"location":"tags/#quick-select","text":"347. Top K Frequent Elements 692. Top K Frequent Words","title":"Quick Select"},{"location":"tags/#recursion","text":"203. Remove Linked List Elements 206. Reverse Linked List 21. Merge Two Sorted Lists 344. Reverse String 89. Gray Code","title":"Recursion"},{"location":"tags/#simulation","text":"1222. Queens That Can Attack the King 537. Complex Number Multiplication 682. Baseball Game","title":"Simulation"},{"location":"tags/#sorting","text":"268. Missing Number 347. Top K Frequent Elements 349. Intersection of Two Arrays 56. Merge Intervals 594. Longest Harmonious Subsequence 692. Top K Frequent Words","title":"Sorting"},{"location":"tags/#stack","text":"2130. Maximum Twin Sum of a Linked List 42. Trapping Rain Water 682. Baseball Game 897. Increasing Order Search Tree","title":"Stack"},{"location":"tags/#string","text":"1092. Shortest Common Supersequence 1143. Longest Common Subsequence 1880. Check if Word Equals Summation of Two Words 1980. Find Unique Binary String 2053. Kth Distinct String in an Array 2085. Count Common Words With One Occurrence 2224. Minimum Number of Operations to Convert Time 344. Reverse String 392. Is Subsequence 516. Longest Palindromic Subsequence 537. Complex Number Multiplication 609. Find Duplicate File in System","title":"String"},{"location":"tags/#tree","text":"100. Same Tree 230. Kth Smallest Element in a BST 513. Find Bottom Left Tree Value 700. Search in a Binary Search Tree 897. Increasing Order Search Tree","title":"Tree"},{"location":"tags/#two-pointers","text":"11. Container With Most Water 1721. Swapping Nodes in a Linked List 344. Reverse String 349. Intersection of Two Arrays 392. Is Subsequence 42. Trapping Rain Water","title":"Two Pointers"},{"location":"tags/#two-pointers_1","text":"2095. Delete the Middle Node of a Linked List 2130. Maximum Twin Sum of a Linked List 876. Middle of the Linked List","title":"Two pointers"},{"location":"tags/#union-find","text":"200. Number of Islands 695. Max Area of Island 785. Is Graph Bipartite?","title":"Union Find"}]}